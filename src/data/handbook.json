{
  "categories": [
    {
      "id": "roadmap",
      "name": "Roadmap",
      "icon": "üó∫Ô∏è",
      "description": "Getting started with robotics - languages, tools, and learning paths",
      "color": "from-purple-500 to-indigo-600"
    },
    {
      "id": "automation",
      "name": "Automation",
      "icon": "ü§ñ",
      "description": "ROS, path planning, control theory, and autonomous systems",
      "color": "from-blue-500 to-cyan-600"
    },
    {
      "id": "electronics",
      "name": "Electronics",
      "icon": "‚ö°",
      "description": "Microcontrollers, sensors, actuators, and circuit design",
      "color": "from-yellow-500 to-orange-600"
    },
    {
      "id": "mechanical",
      "name": "Mechanical",
      "icon": "‚öôÔ∏è",
      "description": "Robot design, kinematics, dynamics, and CAD",
      "color": "from-green-500 to-emerald-600"
    },
    {
      "id": "simulation",
      "name": "Simulation",
      "icon": "üñ•Ô∏è",
      "description": "Gazebo, STDR, and virtual robot testing environments",
      "color": "from-pink-500 to-rose-600"
    }
  ],
  "articles": [
    {
      "id": "roadmap",
      "title": "Roadmap for Robotics",
      "category": "roadmap",
      "excerpt": "A comprehensive guide for beginners covering programming languages, development tools, and learning paths for all aspects of robotics.",
      "content": [
        {
          "type": "heading",
          "value": "Roadmap for Robotics"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "website",
              "url": "http://erc-bpgc.github.io/"
            }
          ]
        },
        {
          "type": "heading",
          "value": "A common beginning"
        },
        {
          "type": "text",
          "value": "As a beginner, the most important thing is to start learning a language since it opens up a lot of opportunities in terms of projects to work on and things to do.  Also keep in mind that once you know one language well, it's relatively easy to pick up another one quickly."
        },
        {
          "type": "text",
          "value": "In robotics, different languages have different uses:"
        },
        {
          "type": "text",
          "value": "1. *Automation*: Machine Learning: python for basic stuff, C++ for more advanced stuff\n2. *Embedded systems and electronics*: C\n3. *Modelling*: python, MATLAB"
        },
        {
          "type": "text",
          "value": "We would recommend starting with either **python** or **C/C++**. Knowing both is pretty much essential for advanced robotics. Here are some places where you can get started:"
        },
        {
          "type": "subheading",
          "value": "Python"
        },
        {
          "type": "text",
          "value": "* [Web tutorial](http://introtopython.org/)\n* [Corey Schafer‚Äôs video tutorials](https://www.youtube.com/playlist?list=PL-osiE80TeTskrapNbzXhwoFUiLCjGgY7)"
        },
        {
          "type": "subheading",
          "value": "C"
        },
        {
          "type": "text",
          "value": "* [FreeCodeCamp Video Tutorials](https://www.youtube.com/watch?v=KJgsSFOSQv0)\n* [Browser based tutorial](https://www.learn-c.org/)\n* [Beej‚Äôs Guide](http://beej.us/guide/bgc/html) (follow if you already know programming)"
        },
        {
          "type": "subheading",
          "value": "C++"
        },
        {
          "type": "text",
          "value": "* [Welcome to C++ Playlist - YouTube](https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb)\n* [Web tutorial](https://www.learncpp.com/)"
        },
        {
          "type": "subheading",
          "value": "MATLAB & Simulink"
        },
        {
          "type": "text",
          "value": "* [MATLAB Onramp](https://in.mathworks.com/learn/tutorials/matlab-onramp.html) and [Simulink Onramp](https://in.mathworks.com/learn/tutorials/simulink-onramp.html). These courses introduce you to the MATLAB and Simulink environments. Many other self paced courses can be found [here](https://matlabacademy.mathworks.com/?s_tid=gn_trg_cosp).\n* This interesting ‚Äú[How to](https://www.youtube.com/playlist?list=PLn8PRpmsu08oBSjfGe8WIMN-2_rwWFSgr)‚Äù playlist by MATLAB teaches some basics how to‚Äôs with MATLAB & Simulink, check out the videos which are required for solving any doubts.\n* [Versioning with Git](https://www.youtube.com/watch?v=AJynESuE1dc&list=PLn8PRpmsu08o7pv1tJ7EnEyHVWSU2-OrR&index=5) this video will help with using Git & Version control with your Simulink projects."
        },
        {
          "type": "heading",
          "value": "Development Environment"
        },
        {
          "type": "text",
          "value": "Writing code isn't just as simple as typing into a text editor. Usually there are many other components involved such as a compiler, external libraries, path environments, a terminal, version control, documentation etc‚Ä¶ Don't worry if you don't know what these things mean, together they are generally known as your development environment. To begin with, make sure you are comfortable with the following"
        },
        {
          "type": "text",
          "value": "* *Linux Operating System*: Linux is an open source operating system - this means that anyone can view and propose changes to its source code. It comes in many variants, Ubuntu being the recommended choice for beginners. It's essential to have access to linux (either through [dual booting](https://help.ubuntu.com/community/WindowsDualBoot), [virtual machine](https://itsfoss.com/install-linux-in-virtualbox/) or [WSL](https://docs.microsoft.com/en-us/windows/wsl/install-win10) - more on these [here](https://erc-bpgc.github.io/handbook/automation/ROS/setting_up/)) due to its tight integration with many of the tools used to program robots (and development in general).\n* *Linux Terminal*: While most of us are familiar with the point and click based interface of windows, computers first started off as terminals - text based prompts that you had to type into. The terminal is still used for pretty much everything in software development and is an essential skill. [YouTube Tutorial](https://youtu.be/oxuRxtrO2Ag)\n* *Git*: When working on complex code, or as part of a team, keeping track of changes to the code becomes very important. Git provides a way to do this and much more. Platforms such as GitHub and GitLab have become the bedrock of the open source community in recent years. [YouTube Tutorial](https://www.youtube.com/watch?v=RGOj5yH7evk)"
        },
        {
          "type": "heading",
          "value": "Electronics"
        },
        {
          "type": "text",
          "value": "The Electronics part of Robotics can be divided into 3 parts : Microcontroller, Sensors and Actuators. Sensors and Actuators (through drivers) are interfaced with the microcontroller to form the electronics system of the robot. Basic electronics components like wires, resistors, capacitors are used in interfacing and this whole assembly is mounted on a breadboard, prototyping board or a printed circuit board (Based on the stage of the project)."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "Arduino",
              "url": "https://www.arduino.cc/en/Guide/Introduction"
            },
            {
              "name": "Arduino IDE",
              "url": "https://www.arduino.cc/en/software"
            },
            {
              "name": "official tutorials",
              "url": "https://www.arduino.cc/en/Tutorial/HomePage"
            },
            {
              "name": "Jeremy Blum",
              "url": "https://www.youtube.com/playlist?list=PLA567CE235D39FA84"
            },
            {
              "name": "Paul McWhorter",
              "url": "https://www.youtube.com/c/mcwhorpj"
            },
            {
              "name": "here",
              "url": "https://erc-bpgc.github.io/handbook/electronics/Development_Boards/Arduino/"
            },
            {
              "name": "TinkedCad",
              "url": "https://www.tinkercad.com/"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "STM32 (BluePill)",
              "url": "https://erc-bpgc.github.io/handbook/electronics/Development_Boards/STM32/"
            }
          ]
        },
        {
          "type": "text",
          "value": "Sensors are electronic components used by the robot to get information about the environment. Some few examples of sensors are wheel encoders, temperature sensors, depth cameras (Kinect), LiDARs, Ultrasound sensors, etc. On the other hand actuators are components using which the robot brings about changes in the environment. Ex. Motors (DC, Stepper, Servo, BLDC), Linear Actuators (Solenoid or a linear servo), etc. Actuators are interfaced with the microcontroller using drivers because of the different power budgets of the microcontroller and the actuators."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "EAGLE",
              "url": "https://www.autodesk.in/products/eagle/overview?plc=F360&term=1-YEAR&support=ADVANCED&quantity=1"
            },
            {
              "name": "official website",
              "url": "https://www.autodesk.in/products/eagle/free-download"
            },
            {
              "name": "Jeremy Blum‚Äôs",
              "url": "https://www.youtube.com/playlist?list=PL868B73617C6F6FAD"
            },
            {
              "name": "Terminal Two‚Äôs",
              "url": "https://www.youtube.com/playlist?list=PLr0mEvO7yBe6QHexsgU2WFUGesFFobGZp"
            }
          ]
        },
        {
          "type": "heading",
          "value": "Automation"
        },
        {
          "type": "subheading",
          "value": "Robot Operating System (ROS)"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this",
              "url": "https://www.youtube.com/watch?v=N6K2LWG2kRI"
            },
            {
              "name": "this",
              "url": "https://www.youtube.com/watch?v=LyC9RAYE96M"
            },
            {
              "name": "this",
              "url": "https://erc-bpgc.github.io/handbook/automation/ROS/ros/"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this",
              "url": "https://erc-bpgc.github.io/handbook/automation/ROS/setting_up/"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "ROS tutorials",
              "url": "http://wiki.ros.org/ROS/Tutorials"
            },
            {
              "name": "here",
              "url": "https://erc-bpgc.github.io/handbook/automation/ROS/ros_p2/"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "ROS Answers",
              "url": "https://answers.ros.org/questions/"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "Hello (Real) World with ROS - Robot Operating System - TU Delft OCW",
              "url": "https://ocw.tudelft.nl/courses/hello-real-world-ros-robot-operating-system/"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "Also refer Morgan Quigley's Programming Robots with ROS",
              "url": "https://www.pdfdrive.com/programming-robots-with-ros-a-practical-introduction-to-the-robot-operating-system-d166617536.html"
            }
          ]
        },
        {
          "type": "subheading",
          "value": "Path Planning"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "here",
              "url": "https://erc-bpgc.github.io/handbook/automation/PathPlanners/intro/"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "book",
              "url": "http://lavalle.pl/planning/"
            },
            {
              "name": "A Star",
              "url": "https://erc-bpgc.github.io/handbook/automation/PathPlanners/Astar/"
            },
            {
              "name": "Dijkstra",
              "url": "https://erc-bpgc.github.io/handbook/automation/PathPlanners/Dijkstra/"
            },
            {
              "name": "RRT",
              "url": "https://erc-bpgc.github.io/handbook/automation/PathPlanners/RRT/"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "Open Motion Planning Library",
              "url": "https://ompl.kavrakilab.org/"
            },
            {
              "name": "this",
              "url": "https://github.com/zhm-real/PathPlanning"
            }
          ]
        },
        {
          "type": "subheading",
          "value": "Simultaneous Localization and Mapping (SLAM)"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "playlist",
              "url": "https://www.youtube.com/playlist?list=PLgnQpQtFTOGQrZ4O5QzbIHgl3b1JHimN_"
            }
          ]
        },
        {
          "type": "subheading",
          "value": "Robot Perception"
        },
        {
          "type": "text",
          "value": "Robot Perception is something that is really underappreciated by beginners as the difficulties behind it are not properly understood. It‚Äôs quite hard to comprehend how hard can seeing, analysing and extracting useful data from a 3D world can be for a robot, as we as humans are quite comfortable in picking and placing objects that are in front of us with utmost precision. It‚Äôs easy for us to avoid tripping over a branch while walking(of course if we see it). But the same is very complex for robots.  Robot Perception specifically deals with this aspect of making intelligent robots."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "the depth map",
              "url": "https://www.omnivirt.com/blog/depth-map/"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "Point Cloud Library",
              "url": "https://pointclouds.org/"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "segmentation",
              "url": "https://towardsdatascience.com/semantic-segmentation-with-deep-learning-a-guide-and-code-e52fc8958823"
            },
            {
              "name": "classification",
              "url": "https://www.analyticsvidhya.com/blog/2019/01/build-image-classification-model-10-minutes/"
            }
          ]
        },
        {
          "type": "subheading",
          "value": "Machine Learning / AI"
        },
        {
          "type": "text",
          "value": "Much of the computer based tools we use follow the same principle - they are a collection of  straightforward instructions for the computer to follow so that it can solve a task. Machine Learning on the other hand, is about how the computer can learn to solve a task from examples, much like we humans learn."
        },
        {
          "type": "text",
          "value": "* Courses\n    * Andrew Ng's classic [machine learning course](https://www.coursera.org/learn/machine-learning) is generally a good place to start.Note that the exercises are in Octave/MATLAB but it's recommended to try them out in python. [This](https://github.com/dibgerge/ml-coursera-python-assignments) repository has a translated version of the exercises.\n    * [Deep Learning](https://www.coursera.org/specializations/deep-learning) by deeplearning.ai is a more advanced course by Andrew NG focusing on Deep Learning.\n    * After completing one of the above, to explore more advanced subfields within machine learning, Stanford has a good set of courses\n        - [Computer Vision](http://cs231n.stanford.edu/) (recommended to do this before the other two)\n        - [Natural Language Processing](http://web.stanford.edu/class/cs224n/)\n        - [Reinforcement Learning](https://www.youtube.com/watch?v=FgzM3zpZ55o&list=PLoROMvodv4rOSOPzutgyCTapiGlY2Nd8u) (also check out [this](https://web.stanford.edu/class/psych209/Readings/SuttonBartoIPRLBook2ndEd.pdf) book)"
        },
        {
          "type": "text",
          "value": "* Software Tools\n    * *Numpy*: Mathematics and Linear Algebra library for python. Essential to know. [YouTube Tutorial](https://www.youtube.com/watch?v=QUT1VHiLmmI) | [Documentation](https://numpy.org/doc/stable/)\n    * *Matplotlib*: Plotting library for python. Essential to know. [YouTube Tutorial](https://www.youtube.com/watch?v=3Xc3CA655Y4) | [Documentation](https://matplotlib.org/)\n    * *SciKitLearn*: Machine Learning toolkit in python. [YouTube Tutorial](https://www.youtube.com/watch?v=pqNCD_5r0IU) | [Documentation](http://scikit-learn.org/stable)\n    * *OpenCV*: Computer vision toolkit [YouTube Tutorial](https://www.youtube.com/watch?v=oXlwWbU8l2o) | [Documentation](https://docs.opencv.org/master/)\n    * *Pytorch*: Deep Learning framework [YouTube Tutorial](https://www.youtube.com/watch?v=GIsg-ZUy0MY) | [Documentation](https://pytorch.org/docs/stable/)\n    * *Tensorflow*: Deep Learning framework [YouTube Tutorial](https://www.youtube.com/watch?v=tPYj3fFJGjk) | [Documentation](https://www.tensorflow.org/)"
        },
        {
          "type": "subheading",
          "value": "Control Systems"
        },
        {
          "type": "text",
          "value": "Control systems help to control the movements and functions of the robot. We need the controllers because the dynamics vary with the time. When the robot moves up in a slope and then down in the slope, or first travels on smooth concrete, then on a carpeted floor. So physical modelling of the ‚ÄúSystem‚Äù becomes crucial for designing a good controller."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this",
              "url": "https://erc-bpgc.github.io/handbook/automation/ControlTheory/Control_Theory/"
            }
          ]
        },
        {
          "type": "text",
          "value": "* To get started with control systems and theory - [Control of Mobile Robots](https://www.youtube.com/playlist?list=PL2jykFOD1AWYvdLW6Alr55IydU_qFVe31) course by Magnus Egerstedt (Georgia Tech), also on Coursera by the same name.\n* [Understanding PID Control](https://www.youtube.com/playlist?list=PLn8PRpmsu08pQBgjxYFXSsODEF3Jqmm-y) - Playlist by MATLAB explains PID control in detail. Also read about the controller over [here](https://erc-bpgc.github.io/handbook/automation/ControlTheory/PID_Controller/).\n* Read about more advanced controllers like Linear-Quadratic Regulator [(LQR)](https://erc-bpgc.github.io/handbook/automation/ControlTheory/LQR/) and Model Predictive Control [(MPC)](https://erc-bpgc.github.io/handbook/automation/ControlTheory/MPC/) here.\n* [This](https://www.youtube.com/playlist?list=PLn8PRpmsu08pFBqgd_6Bi7msgkWFKL33b) playlist teaches some more basic concepts of Control Theory and how to practically apply them.\n* [This](https://www.youtube.com/playlist?list=PLn8PRpmsu08podBgFw66-IavqU2SqPg_w) playlist teaches State space equations, pole placement and concepts like controllability. These become essential when dealing with the math behind Control Theory."
        },
        {
          "type": "heading",
          "value": "Mechanical Design"
        },
        {
          "type": "subheading",
          "value": "CAD"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "link",
              "url": "https://www.autodesk.com/education/edu-software/overview?sorting=featured&page=1"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "official tutorials",
              "url": "https://help.autodesk.com/view/fusion360/ENU/courses/"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "Lynda Tutorials SolidWorks",
              "url": "https://drive.google.com/drive/folders/1j9J3IEnAwjRMRvQAYGQYorKHM698ScX9?usp=sharing"
            }
          ]
        },
        {
          "type": "text",
          "value": "For more information on how to get Solidworks, get in touch with an ERC member."
        }
      ]
    },
    {
      "id": "automation-intro",
      "title": "Introduction to Automation",
      "category": "automation",
      "excerpt": "Overview of automation in robotics - planning, control systems, and state estimation for autonomous robots.",
      "content": [
        {
          "type": "heading",
          "value": "Introduction"
        },
        {
          "type": "text",
          "value": "Robots would be pretty useless without having the ability to do stuff on their own. Today, with ever more powerful machine learning techniques, robots are on their way to becoming truly autonomous. \nDifferent aspects of Automation include Planning, Controls and State estimation."
        },
        {
          "type": "text",
          "value": "From the moment we wake up in the morning until our head hits the pillow at night, we must plan our actions. A large problem in the development of autonomous robots is devising a way to give them the capabilities to make their own plans in a variety of situations.  Motion planning refers to the computational process of moving from one place to another in the presence of obstacles."
        },
        {
          "type": "text",
          "value": "The Robot control system directs the motion and sensory processing of a robot .We need the controllers for the robot because the dynamics (system plant) vary with the time. Such as when the robot moves up in a slope and then down in the slope, or first travels on smooth concrete, then on a carpeted floor."
        },
        {
          "type": "text",
          "value": "A key aspect of robotics today is estimating the state, such as position and orientation, of a robot as it moves through the world. Most robots and autonomous vehicles depend on noisy data from sensors such as cameras or laser rangefinders or a combination of these to localise themselves in a three-dimensional world."
        }
      ]
    },
    {
      "id": "ros-setup",
      "title": "Setting Up ROS",
      "category": "automation",
      "excerpt": "Complete guide to setting up your ROS development environment including OS, ROS installation, and essential tools.",
      "subcategory": "ROS",
      "content": [
        {
          "type": "heading",
          "value": "Preparing your Development Environment"
        },
        {
          "type": "text",
          "value": "One of the most essential and widely used tools for robot automation in __Robot Operating System__ or __ROS__. This section will guide you through how to setup ROS and other tools on your computer."
        },
        {
          "type": "heading",
          "value": "1. Operating System"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "Ubuntu 18.04",
              "url": "https://releases.ubuntu.com/18.04.4/"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this",
              "url": "https://itsfoss.com/install-ubuntu-1404-dual-boot-mode-windows-8-81-uefi/"
            },
            {
              "name": "option",
              "url": "https://www.youtube.com/watch?v=IQIaDO9nR6Y&app=desktop"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "VirtualBox",
              "url": "https://www.virtualbox.org/"
            },
            {
              "name": "VirtualBox",
              "url": "https://www.virtualbox.org/"
            },
            {
              "name": "here",
              "url": "https://ethz.ch/content/dam/ethz/special-interest/mavt/robotics-n-intelligent-systems/rsl-dam/ROS2020/CoursePreparation.pdf"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "WSL",
              "url": "https://ubuntu.com/wsl"
            },
            {
              "name": "here",
              "url": "https://janbernloehr.de/2017/06/10/ros-windows"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "ROS Development Studio",
              "url": "https://www.theconstructsim.com/"
            }
          ]
        },
        {
          "type": "heading",
          "value": "2. Robot Operating System (ROS)"
        },
        {
          "type": "text",
          "value": "Note that this part is unnecessary if you followed the given instructions to set up a VM. For everyone else, this part is **essential**. Different versions of Ubuntu need different variants of ROS. Instructions given below -"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "ROS Melodic",
              "url": "http://wiki.ros.org/melodic/Installation/Ubuntu"
            },
            {
              "name": "ROS Kinetic",
              "url": "http://wiki.ros.org/kinetic/Installation/Ubuntu"
            }
          ]
        },
        {
          "type": "heading",
          "value": "3. Useful tools to make your life easier"
        },
        {
          "type": "text",
          "value": "- [Git‚Äã](https://rogerdudler.github.io/git-guide/) : Fundamental tool in open source software development. Used for version\ncontrol and sharing of code."
        },
        {
          "type": "code",
          "language": "bash",
          "value": "\tsudo apt install git"
        },
        {
          "type": "text",
          "value": "- [Terminator](https://terminator-gtk3.readthedocs.io/en/latest/)‚Äã : Terminal Emulator useful for having multiple terminals in a window."
        },
        {
          "type": "code",
          "language": "bash",
          "value": "\tsudo apt install terminator "
        },
        {
          "type": "text",
          "value": "- Code Editors : A good editor can go a long way in boosting productivity. We recommend ‚Äã[VSCode](https://code.visualstudio.com/)‚Äã which has plugins for python and ROS. A comprehensive guide for how to integrate ROS into your favourite IDE can be found [‚Äãhere](http://wiki.ros.org/IDEs)‚Äã."
        },
        {
          "type": "heading",
          "value": "4. ROS Packages"
        },
        {
          "type": "text",
          "value": "- You can install already developed ROS packages using the apt (package manager for Ubuntu). Replace <package_name> name of the ROS package"
        },
        {
          "type": "code",
          "language": "bash",
          "value": "\tsudo apt install ros-$ROS_DISTRO-<package_name>"
        },
        {
          "type": "text",
          "value": "- For example Turtlebot is one of the most commonly used ground bots for simulation purposes. You can install Turtlebot and it's related packages using the following command -"
        },
        {
          "type": "code",
          "language": "bash",
          "value": "\tsudo apt install ros-$ROS_DISTRO-turtlebot3-*"
        },
        {
          "type": "heading",
          "value": "5. Tips for getting things to work + some helpful facts"
        },
        {
          "type": "text",
          "value": "- Make a habit of running  sudo apt update before installing packages in linux."
        },
        {
          "type": "text",
          "value": "- For the uninitiated, your  bashrc  file is the configuration file for your bash terminal (the thing you type commands into). It's usually located in your home directory at ~/.bashrc  For more info, check out [this](https://www.youtube.com/watch?v=oxuRxtrO2Ag)."
        },
        {
          "type": "text",
          "value": "- Don‚Äôt forget to source the workspace you want to use. For convenience you can source the workspace on startup by editing your .bashrc file to include the\nfollowing line. Replace <workspace_path> with the path of your workspace"
        },
        {
          "type": "code",
          "language": "bash",
          "value": "\tsource <workspace_path>/devel/setup.bash"
        },
        {
          "type": "text",
          "value": "- You cannot source two workspaces at the same time."
        },
        {
          "type": "text",
          "value": "- Anaconda and ROS cannot be used in the same environment because they\nhave a conflicting python path. As given  here , to deal with this, edit your\nbashrc  file by commenting the anaconda python path like this -"
        },
        {
          "type": "code",
          "language": "bash",
          "value": "\t//  export PATH=\"/home//anaconda3/bin:$PATH \""
        },
        {
          "type": "text",
          "value": "- Use python  pip to install python dependencies. Anaconda should be avoided."
        }
      ]
    },
    {
      "id": "ros-basics",
      "title": "Getting Started with ROS",
      "category": "automation",
      "excerpt": "Learn ROS fundamentals including nodes, topics, publishers, subscribers, and the catkin build system.",
      "subcategory": "ROS",
      "content": [
        {
          "type": "heading",
          "value": "Getting Started with Robot Operating System (ROS)\""
        },
        {
          "type": "heading",
          "value": "1. What is ROS?"
        },
        {
          "type": "text",
          "value": "For someone completely new to ROS, the best way to think about it is a collection of tools and frameworks which make automating robotics projects much easier. Every ROS project\nhas a certain structure which you have to follow. Your job would be to fill in the automation code along defining how the different parts of your code are communicating with one another. Once this is done, the underlying ROS framework takes care of the actual networking and connections."
        },
        {
          "type": "text",
          "value": "ROS also has the advantage of having a large open source community with tons of packages. This means you have a lot of prewritten code to help with your project and you don't have to start from scratch."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "1",
              "url": "https://www.youtube.com/watch?v=J1qT85pTW0w&feature=youtu.be"
            },
            {
              "name": "2",
              "url": "https://www.youtube.com/watch?v=UL1_Ue4rUWs"
            }
          ]
        },
        {
          "type": "image",
          "src": "Graph.png",
          "alt": "Skeleton",
          "caption": "Skeleton"
        },
        {
          "type": "text",
          "value": "A ROS system can be visualized as a graph where all the vertices are ‚Äãnodes and the edges between them are known as ‚Äãtopics. In simple terms nodes are programs that perform a particular task and send out/receive data in the form of messages. These messages are exchanged between two nodes over the topic (edge) connecting them. An example of a typical ROS system is given in the figure to the left wherein ‚Äúrobot‚Äù, ‚Äúlaser‚Äù, ‚Äúmap‚Äù, ‚Äúlocalisation‚Äù and ‚Äúplanner‚Äù are the nodes and the arrows connecting the nodes are the topics. An arrow ‚Äã*from* A to B indicates that the topic carries messages from node ‚ÄãA to node B."
        },
        {
          "type": "heading",
          "value": "2. Reference Material"
        },
        {
          "type": "text",
          "value": "While we have tried our best to provide a concise introduction to the basic concepts in this document, there are a lot of other much more thorough and complete resources that you should follow. This document can be treated more as a reference guide with some useful tips for beginners."
        },
        {
          "type": "text",
          "value": "The two most useful resources you can go through are -"
        },
        {
          "type": "text",
          "value": "- **Programming Robots with ROS** :‚Äã A Practical Introduction to the Robot Operating System by Morgan Quigley.\n- **ROSwiki‚Äã tutorials** : The official ROS [tutorials](http://wiki.ros.org/ROS/Tutorials)."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "The Construct",
              "url": "https://www.youtube.com/channel/UCt6Lag-vv25fTX3e11mVY1Q"
            }
          ]
        },
        {
          "type": "heading",
          "value": "3. Basic Concepts"
        },
        {
          "type": "text",
          "value": "Now let‚Äôs get familiar with some very commonly used terms in ROS development. Along with the following introduction you should go through ‚Äã **Chapter 1 and 2**‚Äã of Morgan Quigley for in depth explanation and examples."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "here",
              "url": "http://wiki.ros.org/catkin/conceptual_overview"
            }
          ]
        },
        {
          "type": "text",
          "value": "_Note : The command used for building a workspace should be consistent everytime, i.e. if the workspace was built using catkin_make the very first time while initializing the workspace, all the subsequent builds should be done using catkin_make. To change the method of build in a pre existing workspace, you can use the command ```catkin clean``` which will clear everything except the source space (src folder) of the workspace. It can then be rebuilt using the desired command._"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "documentation",
              "url": "https://colcon.readthedocs.io/en/released/user/quick-start.html"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this",
              "url": "http://wiki.ros.org/catkin/Tutorials/create_a_workspace"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this",
              "url": "http://wiki.ros.org/ROS/Tutorials/CreatingPackage"
            },
            {
              "name": "this",
              "url": "http://wiki.ros.org/ROS/Tutorials/BuildingPackages"
            }
          ]
        },
        {
          "type": "text",
          "value": "**ROS Nodes and Packages:** A ‚Äãnode is an executable file (could be python or C++) which performs a specific task and communicates with other nodes through ‚Äã topics. ‚ÄãTwo main\nways this is done is through publisher-subscriber relationship or services. All of the programming involved in creating a ROS based project is done while writing these nodes."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this",
              "url": "http://wiki.ros.org/Topics"
            },
            {
              "name": "this",
              "url": "http://wiki.ros.org/ROS/Tutorials/CreatingMsgAndSrv"
            }
          ]
        },
        {
          "type": "text",
          "value": "*Note: A single node can simultaneously act as a subscriber to one topic and a publisher of another topic and a server for one service and the client for another.*"
        },
        {
          "type": "text",
          "value": "**Publisher - Subscriber Model:** ‚ÄãThis is a model through which two nodes can exchange data in the form of messages asynchronously, usually used when a one way stream of\ninformation is involved."
        },
        {
          "type": "text",
          "value": "For example, suppose you are developing a self-driving car and you have a node which processes the video feed from a camera to detect street signs. Whenever it detects a sign,\nit needs to communicate its type and distance from the car to another node which will use this information to control the speed of the car. In this scenario your sign detection node\nwill be a publisher which publishes data about the signs it detects to a specific topic, say signs. ‚ÄãYour controller node will be a subscriber which will subscribe to the ‚Äã signs ‚Äã topic and\nperform a certain task whenever it receives a message on this topic."
        },
        {
          "type": "text",
          "value": "- **Publisher:** The publisher object of a ROS node publishes the data in the form of messages over a topic. There is a particular rate (which the user defines) at which the messages get published.\n- **Subscriber:** The data published by the publisher of one ROS node can be received or ‚Äòsubscribed‚Äô through the Subscriber object of a ROS node. The Subscriber object subscribes to the topic over which any publisher publishes the messages. Every Subscriber object is associated with a callback function which gets called everytime a message is published over the topic."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "C++‚Äã",
              "url": "http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber%28c%2B%2B%29#roscpp_tutorials.2FTutorials.2FWritingPublisherSubscriber.Writing_the_Publisher_Node"
            },
            {
              "name": "pytho‚Äãn",
              "url": "http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber%28c%2B%2B%29#roscpp_tutorials.2FTutorials.2FWritingPublisherSubscriber.Writing_the_Publisher_Node"
            }
          ]
        },
        {
          "type": "text",
          "value": "**Services:**  Another common mode of communication, especially suited when there is a transaction style relationship between the two nodes is the service - consisting of a *server*\nand a *client*."
        },
        {
          "type": "text",
          "value": "For example consider in your self driving car, you have one node to control the movement of the car and another to plan an optimal route to your destination. In such a scenario, the\nmain control node would be the ‚Äã*client* ‚Äãfor the route planning ‚Äã *server*. This means that whenever the controller requires a route to be planned, supposed it finds out the route is\nblocked up ahead, then it would send a request to the server. This request would consist of the current location, the destination as well as any preferences the controller might have (like faster/more comfortable). The server would then compute an optimal route and return it to the client as the response."
        },
        {
          "type": "text",
          "value": "- **Client:** ‚ÄãThis is the node which sends requests to a server. In the client code, you can create a special function which acts as a proxy between the client and server. Whenever you call the function, it sends a request to the server with the arguments passed to it as parameters.\n- **Server:** ‚ÄãThis node constantly monitors for requests from the client. Whenever it receives one, it carries out the required task independently of the client and sends\nback the response when the task is complete."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "C++‚Äã",
              "url": "http://wiki.ros.org/ROS/Tutorials/WritingServiceClient%28c%2B%2B%29"
            },
            {
              "name": "‚Äãpython",
              "url": "http://wiki.ros.org/ROS/Tutorials/WritingServiceClient%28python%29"
            }
          ]
        },
        {
          "type": "heading",
          "value": "4. Getting things running"
        },
        {
          "type": "text",
          "value": "Getting a complete ROS system up and running requires a bit more work than executing a single file. Check out ‚Äã**Chapter 20** of Morgan Quigley for more detailed explanation as well as examples for all of the following tools."
        },
        {
          "type": "text",
          "value": "**ROS Master:** Before running the functional nodes in your system, you should first understand ROS Master. This can be visualised as a central server to which all nodes are connected by default. It allows any node to look up information about any other node. This is essential for connecting nodes within the system. For eg. when a node (A) needs to subscribe to a\ntopic published by another node (B), it will get the network address of node B from ROS Master."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "here",
              "url": "http://wiki.ros.org/roscore"
            }
          ]
        },
        {
          "type": "text",
          "value": "**rosrun:** Once you start the ROS Master, you can now start your own ROS nodes. For this ROS has a special command called  rosrun which lets you run the executable files for your\nnode from anywhere. The format for rosrun is -"
        },
        {
          "type": "code",
          "language": "bash",
          "value": "rosrun <package_name> <executable_name>.py"
        },
        {
          "type": "text",
          "value": "(Replace <package_name> and <executable_name> appropriately)"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "here‚Äã",
              "url": "https://www.guru99.com/file-permissions.html"
            }
          ]
        },
        {
          "type": "code",
          "language": "bash",
          "value": "chmod u+x <executable_name>.py"
        },
        {
          "type": "text",
          "value": "(Replace <executable_name> appropriately)"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "terminator",
              "url": "https://terminator-gtk3.readthedocs.io/"
            }
          ]
        },
        {
          "type": "text",
          "value": "***A note on the tab key in terminal:** Typing out long commands into the terminal can get tedious. So ros has a handy capability of completing your commands for you. Whenever you are using ‚Äã rosrun‚Äã or roslaunch‚Äã, you can type out the first few letters in the package name and then press the **Tab key** on your keyboard. At this point, the package name will be autocomplete, saving you a lot of typing. Try it out, this works with other terminal commands too!*"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this",
              "url": "http://wiki.ros.org/roslaunch/Tutorials"
            }
          ]
        },
        {
          "type": "text",
          "value": "**roscd:** roscd is a command line tool which allows you to navigate or ‚Äòcd‚Äô (change directory) to (in command line terms) a package without knowing its exact path. Note: The workspace in which the package is present needs to be sourced. E.g. If you wish to navigate into the ‚Äòturtlebot3_gazebo‚Äô package you‚Äôll just type the following command in the terminal:"
        },
        {
          "type": "code",
          "language": "bash",
          "value": "roscd turtlebot3_gazebo"
        },
        {
          "type": "text",
          "value": "**rqt_graph:** Once you have your system running, you can obtain a diagram along with other details of the system by running the  rqt_graph command in another terminal window."
        }
      ]
    },
    {
      "id": "ros-parameters",
      "title": "ROS Parameters and Advanced Concepts",
      "category": "automation",
      "excerpt": "Advanced ROS concepts including parameters, launch files, and message types.",
      "subcategory": "ROS",
      "content": [
        {
          "type": "heading",
          "value": "ROS Parameters and Parameter Server"
        },
        {
          "type": "text",
          "value": "Parameter server is a collection of values or parameters that can be retrieved or modified by the nodes during runtime upon requests through command prompt, nodes or launch files. Parameters are intended to be static, globally available values like integers, floats, strings and boolean values and can be stored independently or within a YAML file. Parameters are meant to be gloablly viewable so nodes can easily inspect the configuration state of the system and modify if necessary."
        },
        {
          "type": "subheading",
          "value": "Accessing and setting Parameters"
        },
        {
          "type": "text",
          "value": "#### Via command line \nParameters can be accessed, modified or deleted using the `rosparam` command line utility in the `rosbash` suite of terminal commands.\n1) To list all the parameters : <br/> \n    ```rosparam list```"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "namespace",
              "url": "https://www.theconstructsim.com/ros-5-mins-046-ros-namespace/"
            }
          ]
        },
        {
          "type": "text",
          "value": "2) To assign a value to an already existing parameter or to set a new one : <br/>\n    ```rosparam set <parameter_name> <parameter_value>```"
        },
        {
          "type": "text",
          "value": "Note : You can also load the parameters into the parameter server from a YAML file using <br/>\n    ```rosparam load <filename> <namepsace>```"
        },
        {
          "type": "text",
          "value": "3) To get/read a parameter value : <br/>\n    ```rosparam get <parameter_name>```"
        },
        {
          "type": "text",
          "value": "Note : You can also dump/save the parameters into a YAML file from parameter server using <br/>\n    ```rosparam dump <filename> <namespace>```"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this",
              "url": "http://wiki.ros.org/rosparam"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this",
              "url": "http://wiki.ros.org/rospy/Overview/Parameter%20Server"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this",
              "url": "http://wiki.ros.org/roslaunch/XML/param"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "1",
              "url": "http://wiki.ros.org/Parameter%20Server"
            },
            {
              "name": "2",
              "url": "https://www.clearpathrobotics.com/assets/guides/kinetic/ros/ROS%20Parameter%20Server.html"
            },
            {
              "name": "3",
              "url": "https://www.cse.sc.edu/~jokane/agitr/agitr-small-param.pdf"
            }
          ]
        }
      ]
    },
    {
      "id": "path-planning-intro",
      "title": "Introduction to Path Planning",
      "category": "automation",
      "excerpt": "Overview of path planning algorithms and their applications in robotics.",
      "subcategory": "Path Planning",
      "content": [
        {
          "type": "heading",
          "value": "Path Planning in Robotics"
        },
        {
          "type": "heading",
          "value": "What is a path?"
        },
        {
          "type": "text",
          "value": "Path, as the name suggests is a set of waypoints which a Robot is expected to travel. There can be many criterions for deciding a path that the Robot should follow. Various optimisations, checks are made before deciding an optimial path."
        },
        {
          "type": "heading",
          "value": "Why Planning is important for Autonomous Robots?"
        },
        {
          "type": "text",
          "value": "Path planning is one of the most important primitives for autonomous mobile robots. The ability to be able to travel on its own by finding a collision free, optimal path is an important aspect of making robots autonomous"
        },
        {
          "type": "heading",
          "value": "Path planning for Autonomous Robots"
        },
        {
          "type": "text",
          "value": "Path planning, as illustrated above is an important aspect of autonomous robots. There are various methods how a path is planned. There are various algorithms on path planning. Some of the common features of path planners are:"
        },
        {
          "type": "text",
          "value": "1. Given a start and a goal position(or pose), give out a set of states(positions or velocities) that the robot should take to reach the goal from start.\n2. The path generated should be collision free with the obstacles in the environment.\n3. Generally the path generated should optimise some hueristic(or parameter).\n4. The path generated should be traversable by a robot given its dynamics."
        },
        {
          "type": "heading",
          "value": "Path Planning algorithms"
        },
        {
          "type": "text",
          "value": "The problem to find an optimal path has been studied since many decades. There are many algorithms that are `graph-based`, `sampling-based`. Each branch follows a particular approach to solve the path planning problem."
        },
        {
          "type": "text",
          "value": "#### 1. Graph based algorithms:\nGraph based algorithms overlay a topological graph on a robots configurational space and perform search for an optimal path.\nSome of the notable graph-based algorithms are:"
        },
        {
          "type": "text",
          "value": "- _Dijkstra's Algorithm_\n- _A-Star (A*)_\n- _D-Star (D*)_"
        },
        {
          "type": "text",
          "value": "#### 2. Sampling based algorithms:\nSampling based algorithms represent the configuration space with a roadmap or build a tree, generated by randomly sampling states in the configuration space.\nSome of the notable sampling-based algorithms are:"
        },
        {
          "type": "text",
          "value": "- _Rapidly exploring Random Tree (RRT)_\n- _RRT Star (RRT*)_\n- _Informed RRT Star_\n- _Batch Informed Trees Star (BIT*)_"
        },
        {
          "type": "heading",
          "value": "Additional References"
        },
        {
          "type": "text",
          "value": "1. For a better understanding of the path planning problem refer [here](http://correll.cs.colorado.edu/?p=965).\n2. Understand configuration spaces from this [video](https://www.youtube.com/watch?v=NwwsjVsYTbg)."
        }
      ]
    },
    {
      "id": "path-planning-astar",
      "title": "A* Algorithm",
      "category": "automation",
      "excerpt": "A-star is a graph-based, path search algorithm known for its completeness, optimality, and optimal efficiency.",
      "subcategory": "Path Planning",
      "content": [
        {
          "type": "heading",
          "value": "A-Star Algorithm"
        },
        {
          "type": "text",
          "value": "A-star is a graph-based, path search algorithm. It is used in many fields of computer science as a search algorithm. It is often used due to its completeness, optimality, and optimal efficiency."
        },
        {
          "type": "subheading",
          "value": "Salient Features of the Algorithm"
        },
        {
          "type": "text",
          "value": "1. **Resolution complete** and **Resolution optimal** : The algorithm finds the optimal solution to the given problem at a chosen discretization, if one exits.\n2. A-Star uses a **hueristic** to estimate the total cost of a solution constrained to pass through a state. Thus, it searches in order of decreasing solution quality and is *optimally efficient*.\n3. Any other optimal algorithm using the same hueristic will expand at least as many vertices as A-Star."
        },
        {
          "type": "subheading",
          "value": "Idea of Hueristics Functions"
        },
        {
          "type": "text",
          "value": "- Hueristic functions are used to map every node in the graph to a *non-negative* value.\n- #### Criteria for Hueristics Functions\n    - Should be a _monotonic function_\n    - Should satisfy $H(goal) = 0$\n    - For any two adjacent nodes $x$ and $y$:\n    \t- $H(x, y) \\leq H(y) + d(x, y)$  \n    \t- $d(x, y) = EdgeCost(x, y)$\n    - These properties ensure that for all nodes $n$:\n    \t- $H(n) \\leq length of Shortest Path(n, GOAL)$\n- #### For path Planning on a grid:\n    - **Euclidean Distance:**\n        $H(x_n, y_n) = \\sqrt{(x_n-x_g)^2 + (y_n-y_g)^2}$\n    - **Manhattan Distance:**\n        $H(x_n, y_n) = \\lvert(x_n - x_g) + (y_n - y_g)\\rvert$"
        },
        {
          "type": "text",
          "value": "Where $x_n$, $y_n$ and $x_g$, $y_g$ are the $x$, $y$ coordinates of a the node and the goal respectively."
        },
        {
          "type": "subheading",
          "value": "Psuedo Code for the Algorithm"
        },
        {
          "type": "code",
          "language": "python",
          "value": "def Astar(start, goal, graph):\n    # Set the g, f values for all nodes in the graph\n    for node in graph:\n        node.f = Infinity\n        node.g = Infinity\n\n    # Create an empty list to store visited nodes\n    nodes = []\n\n    # Add Start to nodes list\n    nodes.add(start)\n\n    # Loop to traverse the graph\n    while nodes is not EMPTY:\n        # Obtain bode with the least f-value\n        CURRENT = argmin(node, criteria=node.f)\n\n        # Check if current node is the goal Node\n        # which means the graph has been completely traversed\n        if CURRENT == goal:\n            report \"SUCCESS\"\n            break\n        # Update parameters for adjacent nodes\n        for adjacent_node in CURRENT.adjacent_nodes:\n            if adjacent_node.g > CURRENT.g + cost of edge from n to current:\n                adjacent_node.g = CURRENT.g + cost of edge from n to current\n                adjacent_node.f = adjacent_node.g + H(node)\n                adjacent_node.parent = CURRENT\n\n                # Add the adjacent node to nodes list if not there already\n                if adjacent_node not in nodes:\n                    nodes.add(adjacent_node)"
        },
        {
          "type": "text",
          "value": "**Notations in the Psuedo Code explained**:"
        },
        {
          "type": "code",
          "language": "text",
          "value": "g-value = distance between a node and the start node\nH-function = Hueristic funciton\nf-value = g-value + Hueristic value of the node"
        },
        {
          "type": "subheading",
          "value": "References"
        },
        {
          "type": "text",
          "value": "1. Original [paper](https://ieeexplore.ieee.org/document/4082128) on A-Star path planning algorithm.\n2. Psuedo Code can be found [here](https://mat.uab.cat/~alseda/MasterOpt/AStar-Algorithm.pdf)\n3. Video explainig A-star can be found [here](https://www.youtube.com/watch?v=5n8OtzqVOyg)"
        }
      ]
    },
    {
      "id": "path-planning-dijkstra",
      "title": "Dijkstra's Algorithm",
      "category": "automation",
      "excerpt": "Dijkstra's algorithm for finding shortest paths between nodes in a graph.",
      "subcategory": "Path Planning",
      "content": [
        {
          "type": "heading",
          "value": "Dijkstra's Algorithm"
        },
        {
          "type": "text",
          "value": "Dijkstra's Algorithm is an algorithm for finding the shortest path between one source node and all the other nodes in a graph, thereby producing a `shortest-path-tree`."
        },
        {
          "type": "subheading",
          "value": "Psuedo Code"
        },
        {
          "type": "code",
          "language": "python",
          "value": "# Set the distances if all nodes in the graph to infinty\nfor node in graph:\n    node.distance = INFINITY\n\n# Create an empty list\nnodes = []\n\n# Set the start distance to ZERO\nSTART.distance = 0\n\n# Add start to the list\nnodes.add(START)\n\n# Loop to update distances\nwhile nodes is not empty:\n    CURRENT = argmin(node, criteria=node.distance)\n\n    if CURRENT == GOAL:\n        report \"Success\"\n        break\n\n    for adjacent_node in CURRENT.adjacent_nodes:\n        if adjacent_node.distance > CURRENT.distance + cost of edge from CURRENT to adjacent_node:\n            adjacent_node.distance = CURRENT.distance + cost of edge from CURRENT to adjacent_node\n            adjacent_node.parent = CURRENT\n\n            # Add adjacent_node to the list, if it is not already present\n            if adjacent_node not in nodes:\n                nodes.add(adjacent_node)"
        },
        {
          "type": "subheading",
          "value": "References:"
        },
        {
          "type": "text",
          "value": "1. Psuedo Code for Dijkstra's Algorithm can be found [here](http://www.gitta.info/Accessibiliti/en/html/Dijkstra_learningObject1.html)\n2. A video explaining Dijkstra's Algorithm can be found [here](https://www.youtube.com/watch?v=GazC3A4OQTE)"
        }
      ]
    },
    {
      "id": "path-planning-rrt",
      "title": "Rapidly-exploring Random Tree (RRT)",
      "category": "automation",
      "excerpt": "RRT is a sampling-based path planning algorithm for high-dimensional spaces.",
      "subcategory": "Path Planning",
      "content": [
        {
          "type": "heading",
          "value": "Rapidly Exploring Random Trees"
        },
        {
          "type": "subheading",
          "value": "Salient Features"
        },
        {
          "type": "text",
          "value": "1. Randomly samples nodes in the Configuration space of the robot to build a tree of valid configurations.\n2. It is **Probabilistically Complete**,having the probability to find a solution _if it exists_. In worst case, time taken to find a solution can be very long (longer than exhaustive search). The probability of finding a solution goes to $1$ as number of sampled nodes goes to $\\infty$.\n3. In practise, the algorithm tends to be very effecitve in high dimensional spaces.\n4. There is no gaurantee regarding the optimality of the solution. The path produced my bot the the shortest path.\n5. Post processing of the path generated is required as the path generated is often very unordered or in zig-zag fashion."
        },
        {
          "type": "subheading",
          "value": "Intuition"
        },
        {
          "type": "text",
          "value": "The basic idea behind the algorithm is to start out at a start node and to generate random points in the configuration space and the tree is extended by connecting the randomly generated point to the closest node in the existing tree available."
        },
        {
          "type": "text",
          "value": "There are a few key things to note here. Firstly, the points aren't joined directly. We take a **maximum distance between sampled node and nearest node** (called `DELTA` in the pseudocode). We extend the nearest node by this distance towards the randomly sampled node, if the sampled node is farther than this distance. Otherwise, if the sampled node is closer than this value, we directly connect the two nodes."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/rrt01.png",
          "alt": "Joon&#39;s Lectures: Improving the Optimality of RRT: RRT*",
          "caption": "Joon&#39;s Lectures: Improving the Optimality of RRT: RRT*"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "Joon's Lectures",
              "url": "https://joonlecture.blogspot.com/2011/02/improving-optimality-of-rrt-rrt.html"
            }
          ]
        },
        {
          "type": "text",
          "value": "In the above image, $q_{rand}$ is the randomly sampled point, $q_{nearest}$ is the nearest (to $q_{rand}$) point in the tree. Since the distance between $q_{rand}$ and $q_{nearest}$ is greater than the maximum distance $v$, we connect $q_{nearest}$ to $q_{new}$, which is at a distance of $v$ from $q_{nearest}$."
        },
        {
          "type": "text",
          "value": "This process is continuously carried out for many iterations until the goal is reached. The tree expands rapidly, and hence the name."
        },
        {
          "type": "subheading",
          "value": "Collision Checking Function"
        },
        {
          "type": "text",
          "value": "One important requirement of sampling algorithms, is the ability to check if a configuration is valid or not. To check if a configuration $X$ is valid in a _configuration free space_ $\\mathbb{C}$, a function as such can be used:"
        },
        {
          "type": "text",
          "value": "$$\n\tCollisionCheck(X) = \\begin{cases}\n\t\t\t\t\t\t\t\t0 \\quad &\\text{if} \\, X \\in \\mathbb{C} \\\\\n\t\t\t\t\t\t\t\t1 \\quad &\\text{if} \\, X \\notin \\mathbb{C}\n\t\t\t\t\t\t\\end{cases} \\\\\n$$"
        },
        {
          "type": "subheading",
          "value": "Psuedo Code"
        },
        {
          "type": "code",
          "language": "python",
          "value": "def RRT(START, GOAL):\n\tTREE = []\n\tTREE.add(START)\n\tDELTA = maximum distance between sampled node and nearest node. \n\tREPEAT n times:\n\t\tX = generateNewConfiguration()\n\t\tif X in FREE_SPACE:\n\t\t\tfor nodes in TREE:\n\t\t\t\tY = argmin(nodes, criteria=distance)\n\t\t\tif DIST(X, Y) < DELTA:\n\t\t\t\tFind a configuration Z that is at DELTA distance along the path from X to Y\n\t\t\t\tif TRAVERSABLE(X, Z):\n\t\t\t\t\tX.parent = Y\n\t\t\t\t\tTREE.add(X)\n\t\t\telse:\n\t\t\t\tif TRAVERSABLE(X, Y):\n\t\t\t\t\tX.parent = Y\n\t\t\t\t\tTREE.add(X)\n\t\t\tif X is GOAL:\n\t\t\t\treport \"SUCCESS\"\n\t\t\t\tbreak\n"
        },
        {
          "type": "subheading",
          "value": "Notations and Functions used in Psuedo Code:"
        },
        {
          "type": "text",
          "value": "- Function used to check if a path is traversable:"
        },
        {
          "type": "text",
          "value": "$$\n\tTraversable(X, Y) = \\begin{cases}\n\t\t\t\t\t\t1 \\quad &\\text{if} \\, \\operatorname{LineJoining}(X, Y) \\in \\mathbb{C} \\\\\n\t\t\t\t\t\t0 \\quad &\\text{if} \\, \\operatorname{LineJoining}(X, Y) \\notin \\mathbb{C} \\\\\n\t\t\t\t\t\t\\end{cases}\n$$"
        },
        {
          "type": "text",
          "value": "- In case of Rotations:"
        },
        {
          "type": "text",
          "value": "$$\n\tDist(X, Y) = \\min{(\\lvert X_n - Y_n \\rvert}, \\lvert\\ 2\\pi - \\lvert X_n - Y_n \\rvert \\rvert) \n$$"
        },
        {
          "type": "subheading",
          "value": "References"
        },
        {
          "type": "text",
          "value": "1. Refer [this](https://medium.com/@theclassytim/robotic-path-planning-rrt-and-rrt-212319121378) article for more information about RRT and RRT*\n2. A [video](https://www.youtube.com/watch?v=xAmN8WnltRY) explaining RRT algorithm.\n3. Refer to the paper [here](http://msl.cs.illinois.edu/~lavalle/papers/Lav98c.pdf)"
        }
      ]
    },
    {
      "id": "path-planning-rrt-star",
      "title": "RRT* (RRT Star)",
      "category": "automation",
      "excerpt": "An optimized version of RRT that provides asymptotically optimal solutions.",
      "subcategory": "Path Planning",
      "content": [
        {
          "type": "heading",
          "value": "Optimal Rapidly Exploring Random Trees (RRT*)"
        },
        {
          "type": "text",
          "value": "In the year 2011, Sertac Karaman and Emilio Frazzoli in their paper *Sampling-based Algorithms for Optimal Motion Planning*, introduced three new path planning algorithms that improved upon the existing algorithms. These were, namely, **optimal rapidly exploring random trees (RRT\\*), optimal probabilistic road mapping (PRM\\*),** and **rapidly exploring random graphs (RRG)**."
        },
        {
          "type": "text",
          "value": "The most popular algorithm among these is the RRT* algorithm, that is heavily based on the RRT algorithm, and has some improvisions, and provides a more optimal solution."
        },
        {
          "type": "text",
          "value": "Let's now look at the RRT* algorithm that was originally proposed in the paper along with the pseudo code. All the mathematical notations and functions in the paper are clearly explained here."
        },
        {
          "type": "text",
          "value": "The following image shows the RRT* algorithm applied on a 2D graph."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/rrt_star_visualisation.png",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "SAI VEMPRALA",
              "url": "https://www.mathworks.com/matlabcentral/profile/authors/4026649"
            }
          ]
        },
        {
          "type": "heading",
          "value": "Intuition"
        },
        {
          "type": "text",
          "value": "The node sampling and selection process is exactly the same as RRT, wherein a point is randomly generated and a node is created at that point or at a specified maximum distance from the existing node, whichever is closer."
        },
        {
          "type": "text",
          "value": "However, the difference is where the connection is made. We assign every node a **cost function** that denotes the length of the shortest path from the start node. We then search for nodes inside a circle of given radius r centred at the newly sampled point."
        },
        {
          "type": "text",
          "value": "We then rearrange the connections such that they **minimize the cost function** and optimize the path. This can rearrange the graph in such a way that we get the shortest path."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/rrt_star_algo.png",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "Joon's lectures",
              "url": "https://joonlecture.blogspot.com/2011/02/improving-optimality-of-rrt-rrt.html"
            }
          ]
        },
        {
          "type": "text",
          "value": "In the image above, after rearranging the connections, the path to the green points, i.e., $q_{near}$ is shorter through the red connections than through the earlier connections.\n&nbsp;"
        },
        {
          "type": "heading",
          "value": "Pseudocode"
        },
        {
          "type": "text",
          "value": "The following is the pseudocode for the RRT* algorithm. An explanation of all the unique functions used in the pseudocode is explained below."
        },
        {
          "type": "code",
          "language": "python",
          "value": "def RRT_Star(V, E, r, c):\n\tV = [x_init]\n\tE = []\n\t# G = (V, E)\n\tfor i in range(1, n):\n\t\tx_rand = SampleFree()\n\t\tx_nearest = Nearest(V, E, x_rand)\n\t\tx_new = Steer(x_nearest, x_rand)\n\t\tif ObstacleFree(x_nearest, x_new):\n\t\t\tX_near = Near(V, E, x_new, r)\n\t\t\t# list of all nodes at radius r\n\t\t\tV.append(x_new)\n\t\t\tx_min = x_nearest\n\t\t\tc_min = cost(x_nearest) + c(Line(x_nearest, x_new))\n\t\t\t# the cost of the nearest node to new node\n\t\t\t# to check whether to change paths\n\n\t\t\tfor x_near in X_near:\n\t\t\t\tif CollisionFree(x_near, x_new)*Cost(x_near)+c(Line(x_near, x_new)) < c_min:\n\t\t\t\t\tx_min = x_near\n\t\t\t\t\tc_min = Cost(x_near) + c(Line(x_near, x_new))\n\t\t\t\t\t# update c_min, because we now need to find nodes that are closer than this new x_new\n\n\t\t\tE.append([x_min, x_new])\n\n\t\t\tfor x_near in X_near:\n\t\t\t\tif CollisionFree(x_new, x_near)*Cost(x_new) + c(Line(x_new, x_near)) < Cost(x_near):\n\t\t\t\t\tx_parent = Parent(x_near)\n\t\t\t\t\tE.remove([x_parent, x_near])\n\t\t\t\t\tE.append([x_new, x_near])\n\t\t\t\t\t# remove all edges between nodes (in radius r) and their parents and join them with x_new\n\t\t\t\t\t# this is the step of reconnection of edges\n\treturn V, E\n"
        },
        {
          "type": "text",
          "value": "&nbsp;"
        },
        {
          "type": "heading",
          "value": "Functions used in Pseudocode"
        },
        {
          "type": "subheading",
          "value": "`SampleFree()`"
        },
        {
          "type": "text",
          "value": "The function `SampleFree()` is used to return a randomly sampled node. The samples are generally assumed to be drawn from a uniform distribution."
        },
        {
          "type": "text",
          "value": "Suppose the set of sample space is given as $\\Omega$ and for each $\\omega \\in \\Omega$,"
        },
        {
          "type": "text",
          "value": "is a map from $\\Omega$ to a sequence of points $\\mathcal{X_{free}}$, which is the obstacle-free space."
        },
        {
          "type": "subheading",
          "value": "`Nearest()`"
        },
        {
          "type": "text",
          "value": "This function is used to return the nearest node in the graph."
        },
        {
          "type": "text",
          "value": "Let's say that our tree is a graph $G=(V,E)$ where $V$ and $E$ are sets of vertices and edges of our tree, where $V\\subset \\mathcal{X}$. We take a point $x\\in \\mathcal{X}$ such that the function $Nearest:(G,x)\\mapsto v \\in V$ returns the node $v$ in $V$ that is closest to the point $x$ in terms of a distance function, such as Euclidean distance, i.e.,"
        },
        {
          "type": "text",
          "value": "where $argmin_{v \\in V} ||x-v||$ means that the value $v$ in $V$ is returned such that the distance $||x-v||$ is minimum."
        },
        {
          "type": "subheading",
          "value": "`Near()`"
        },
        {
          "type": "text",
          "value": "This function is used to find the nodes in the graph in a fixed radius in order to rearrange the connections such that we get the optimal path."
        },
        {
          "type": "text",
          "value": "Let's say the radius is $r$ such that $r\\in \\mathbb{R}$. The function $Near:(G,x,r)\\mapsto V'\\subseteq V$ returns the vertices $V'$ in $V$ that are contained in a circle of radius $r$ centred $x$, i.e.,"
        },
        {
          "type": "text",
          "value": "where $\\mathfrak{B}_{x,r}$ is the set of all points within the fixed radius $r$ centred at $x$."
        },
        {
          "type": "subheading",
          "value": "`Steer()`"
        },
        {
          "type": "text",
          "value": "This function is the one that creates a new node that is at a maximal distance from the nearest node in the direction of the sampled node (or it's equal to the sampled node itself, if it's closer than this distance)."
        },
        {
          "type": "text",
          "value": "Suppose we have two points $x,y\\in \\mathcal{X}$. The function $Steer:(x,y)\\mapsto z$ returns a point $z \\in \\mathcal{X}$ such that $z$ is closer to $y$ than $x$ is. This will be such that $z$ minimizes the distance $||z-y||$ and at the same time maintains the distance $||z-x||\\leq\\eta$ for the predefined maximal distance $\\eta > 0$, i.e.,"
        },
        {
          "type": "subheading",
          "value": "`Line()`"
        },
        {
          "type": "text",
          "value": "The `Line()` function is used to denote a straight line, i.e., given two points $x_1,x_2\\in \\mathbb{R}^d$,"
        },
        {
          "type": "subheading",
          "value": "`Parent()`"
        },
        {
          "type": "text",
          "value": "The `Parent()` function is used to denote the parent node of a given node in a tree, i.e., given a tree $G=(V,E)$, $Parent:V\\mapsto V$ is a function that maps a vertex $v\\in V$ to the unique vertex $u\\in V$ such that $(u,v)\\in E$."
        },
        {
          "type": "text",
          "value": "Note that if $v_0 \\in V$ is the start node of $G$, then, by convention, $Parent(v_0)=v_0$."
        },
        {
          "type": "subheading",
          "value": "`Cost()`"
        },
        {
          "type": "text",
          "value": "This is function that makes RRT* different from RRT. As mentioned before, we assign each node a cost that is a function of the distance along the path from the start node. It's given as follows.If $Cost:V\\mapsto \\mathbb{R}^+$ is a function that maps the vertex $v_0\\mapsto V$ to the cost of the unique path from the root of the tree to $v$, then"
        },
        {
          "type": "text",
          "value": "where $c$ is a function that transforms the length value of the $Line$ into a cost"
        },
        {
          "type": "text",
          "value": "Note that if $v_0$ is the start node or root vertex of $G$, then, by convention, $Cost(v_0)=0$."
        },
        {
          "type": "subheading",
          "value": "`CollisionFree()`"
        },
        {
          "type": "text",
          "value": "`CollisionFree(x,x')` returns `True` if the line segment joining x and x' lies in $\\mathcal{X_{free}}$, where $x,x'\\in \\mathcal{X}$ and `False` otherwise.\n&nbsp;"
        },
        {
          "type": "heading",
          "value": "Visual comparison between RRT and RRT*"
        },
        {
          "type": "text",
          "value": "The following image shows the RRT and RRT\\* algorithms applied on a 2D graph with obstacles. The plot on the left is RRT and the plot on the right is RRT*. As one can see, the RRT\\* algorithm provides a more optimal solution to the path planning problem."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/rrt_vs_rrt_star.png",
          "alt": "A Comparison of the RRT (a) and RRT* (b) algorithms on an example (Karaman and Frazzoli, 2011)",
          "caption": "A Comparison of the RRT (a) and RRT* (b) algorithms on an example (Karaman and Frazzoli, 2011)"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "Andr√°s Gyimesi",
              "url": "https://www.researchgate.net/profile/Andras-Gyimesi"
            }
          ]
        },
        {
          "type": "heading",
          "value": "A flowchart summary of the RRT* algorithm"
        },
        {
          "type": "text",
          "value": "The following flowchart provides a visual summary of the optimal rapidly exploring random trees algorithm."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/rrt_star_summary.png",
          "alt": "MEAQR RRT* Algorithm Flowchart¬†",
          "caption": "MEAQR RRT* Algorithm Flowchart¬†"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "Nir Rikovitch",
              "url": "https://www.researchgate.net/profile/Nir-Rikovitch"
            }
          ]
        },
        {
          "type": "heading",
          "value": "References"
        },
        {
          "type": "text",
          "value": "- The [paper](https://arxiv.org/abs/1105.1186) by Karaman and Frazzoli.\n- Refer this [article](https://theclassytim.medium.com/robotic-path-planning-rrt-and-rrt-212319121378) for a synopsis.\n- Watch this [video](https://www.youtube.com/watch?v=QR3U1dgc5RE) and this [video](https://www.youtube.com/watch?v=Ob3BIJkQJEw) for visualization of the algorithm."
        }
      ]
    },
    {
      "id": "path-planning-prm",
      "title": "Probabilistic Roadmap (PRM)",
      "category": "automation",
      "excerpt": "PRM is a sampling-based algorithm that creates a roadmap of the free space.",
      "subcategory": "Path Planning",
      "content": [
        {
          "type": "heading",
          "value": "Probabilistic Roadmaps"
        },
        {
          "type": "heading",
          "value": "Introduction"
        },
        {
          "type": "text",
          "value": "The probabilistic roadmap method is a fairly simple sampling based path planning method, compared to the other sampling based algorithms, RRT and RRT\\*. It was introduced in the paper titled *Probabilistic Roadmaps for Path Planning in High-Dimensional Configuration Spaces*, and the invention of the PRM method is credited to Lydia E. Kavraki."
        },
        {
          "type": "text",
          "value": "As this is a sampling based algorithm, it involves randomly sampling points in a given space."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/prm_visualisation.gif",
          "alt": "Probabilistic roadmap - Wikipedia",
          "caption": "Probabilistic roadmap - Wikipedia"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "Wikipedia",
              "url": "https://en.wikipedia.org/wiki/Probabilistic_roadmap"
            }
          ]
        },
        {
          "type": "text",
          "value": "This algorithm is divided into two phases, namely, the **learning phase** and the **query phase**."
        },
        {
          "type": "text",
          "value": "- In the learning phase, the roadmap containing nodes and edges is generated. These nodes and edges are entirely inside the search space and do not overlap with obstacles."
        },
        {
          "type": "text",
          "value": "- In the query phase, graph based algorithms, like A* and Dijkstra's algorithms, are used on the probabilistic roadmap to find the optimal path."
        },
        {
          "type": "text",
          "value": "It is important to first get an intuition of the algorithm before moving on to the pseudocode.\n&nbsp;"
        },
        {
          "type": "heading",
          "value": "How it works"
        },
        {
          "type": "subheading",
          "value": "Learning Phase"
        },
        {
          "type": "text",
          "value": "The robot in question can only take certain configurations and positions in a given space. The set of all these configurations is called the configuration space or **C-space**."
        },
        {
          "type": "text",
          "value": "In a given space, the first step is to **randomly generate a point**. It is then checked whether this point is in C-space or not."
        },
        {
          "type": "text",
          "value": "If it is in C-space, we add this point to the graph by connecting it to all the points in the graph that are within a specific radius from the generated point by a straight line. It also checks whether this line is in free space, and only forms this connection if it is."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/prm_algo.svgz",
          "alt": "Adaptation Algorithm of Geometric Graphs for Robot Motion Planning in  Dynamic Environments",
          "caption": "Adaptation Algorithm of Geometric Graphs for Robot Motion Planning in  Dynamic Environments"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "Mathematical Problems in Engineering",
              "url": "https://www.hindawi.com/journals/mpe/2016/3973467/"
            }
          ]
        },
        {
          "type": "text",
          "value": "In the above diagram, a node $q_i$ was randomly generated. Nodes within the radius $r_{\\eta}$ are searched for and connected to $q_i$ through edges."
        },
        {
          "type": "text",
          "value": "This process is then repeated as many times as necessary. As the number of samples tends to infinity, the likelihood that the graph is a true road map tends to 100%."
        },
        {
          "type": "text",
          "value": "Once this is done, we add the start node and the goal node by joining a line from each of the two to the closest node in the graph to each of them.\n&nbsp;"
        },
        {
          "type": "subheading",
          "value": "Query Phase"
        },
        {
          "type": "text",
          "value": "This phase involves using the nodes of the roadmap generated in the learning phase as points on a graph and **use graph based algorithms** like A* and Dijkstra to come up with an optimal path for the robot to take."
        },
        {
          "type": "text",
          "value": "Given the start and goal configurations, $s$ and $g$, the method tries to connect them to two nodes $\\tilde{s}$ and $\\tilde{g}$ in the graph. If succesful, the method tries to find the optimal path from $s$ to $g$ using graph based algorithms."
        },
        {
          "type": "text",
          "value": "We have already covered graph based algorithms separately so you can refer to those for how they work."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/prm_query_phase.png",
          "alt": "2: Probabilistic Roadmaps. The blue nodes are the sampled collision... |  Download Scientific Diagram",
          "caption": "2: Probabilistic Roadmaps. The blue nodes are the sampled collision... |  Download Scientific Diagram"
        },
        {
          "type": "text",
          "value": "One interesting thing to note is that the **learning phase and query phase can be interwoven**, i.e., the two phases don't need to be carried out sequentially."
        },
        {
          "type": "text",
          "value": "For example, we might first create a small roadmap and then apply graph based algorithms on it. We might simultaneously perform the learning phase and connect new nodes generated to the path to create a more optimal path as both phases are being carried out simultaneously."
        },
        {
          "type": "text",
          "value": "For this section, however, we will assume the learning phase has been carried out before performing query phase."
        },
        {
          "type": "text",
          "value": "Let's now look at the pseudocode that describes the algorithm. The functions used in the pseudocode are explained in our page on the RRT\\* algorithm, under the section \"Functions used in Pseudocode\".\n&nbsp;"
        },
        {
          "type": "heading",
          "value": "Pseudocode"
        },
        {
          "type": "text",
          "value": "The following pseudocode only performs the learning phase for the PRM algorithm. The query phase has not been included in the pseudocode."
        },
        {
          "type": "code",
          "language": "python",
          "value": "def PRM(n, r, x_init, x_goal):\n\tV = []\n\tE = []\n\tfor i in range(n):\n\t\tx_rand = SampleFree()\n\t\tU = Near(V, E, x_rand, r)\n\t\tV.append(x_rand)\n\t\tU.Sort(distance(x_rand))\n\t\tfor u in U:\n\t\t\tif [[x_rand, u], [u, x_rand]] not in E:\n\t\t\t\tif CollisionFree(x_rand, u):\n\t\t\t\t\tE.append([[x_rand, u], [u, x_rand]])\n\n\treturn V, E"
        },
        {
          "type": "text",
          "value": "In this psuedocode, the function `U.Sort(distance(x_rand))` sorts the list `U` according to the Euclidean distance between each element of the list and `x_rand`, in increasing order.\n&nbsp;"
        },
        {
          "type": "heading",
          "value": "References"
        },
        {
          "type": "text",
          "value": "1. The original [paper](https://www.researchgate.net/publication/3298646_Probabilistic_Roadmaps_for_Path_Planning_in_High-Dimensional_Configuration_Spaces) on PRM.\n2. You can watch this [video](https://www.youtube.com/watch?v=rKe6HO8LDu0) for a brief explanation.\n3. Refer this [video](https://www.youtube.com/watch?v=ujvgJzgZ9xg) to code this algorithm on MATLAB."
        }
      ]
    },
    {
      "id": "control-theory-intro",
      "title": "Introduction to Control Theory",
      "category": "automation",
      "excerpt": "Fundamentals of control systems for robotics applications.",
      "subcategory": "Control Theory",
      "content": [
        {
          "type": "heading",
          "value": "Control Theory"
        },
        {
          "type": "text",
          "value": "A robot can exhibit a number of different behaviors, depending on the task and its environment. It can act as a source of programmed motions for tasks such as moving an object from one place to another or tracing a trajectory. It can act as a source of forces, as when applying a polishing wheel to a workpiece. In tasks such as writing on a chalkboard, it must control forces in some directions (the force must press the chalk against the board) and motions in others (the motion must be in the plane of the board). When the purpose of the robot is to act as a haptic display, rendering a virtual environment, we may want it to act like a spring, damper, or mass, yielding in response to forces applied to it."
        },
        {
          "type": "text",
          "value": "In each of these cases, it is the job of the robot controller to convert the task specification to forces and torques at the actuators. Control strategies that achieve the behaviors described above are known as **motion control**, **force control**, **hybrid motion-force control**, or **impedance control**."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/controller.png",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "text",
          "value": "A typical control block diagram is shown above The sensors are typically: potentiometers, encoders, or resolvers for joint position and angle sensing; tachometers for joint velocity sensing; joint force-torque sensors; and/or multi-axis force-torque sensors."
        },
        {
          "type": "heading",
          "value": "Types of control systems"
        },
        {
          "type": "subheading",
          "value": "Open Loop control system"
        },
        {
          "type": "text",
          "value": "A control system in which the control action is totally independent of output of the system then it is called **open loop control system**. A manual control system is also an open loop control system. The figure below shows a control system block diagram of an open loop control system in which process output is totally independent of the controller action."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/controller_1.png",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "text",
          "value": "**Practical examples of Open loop control system:**"
        },
        {
          "type": "text",
          "value": "1. Electric Hand Drier ‚Äì Hot air (output) comes out as long as you keep your hand under the machine, irrespective of how much your hand is dried.\n2. Automatic Washing Machine ‚Äì This machine runs according to the pre-set time irrespective of washing is completed or not.\n3. Bread Toaster ‚Äì This machine runs as per adjusted time irrespective of toasting is completed or not."
        },
        {
          "type": "subheading",
          "value": "Closed Loop control system"
        },
        {
          "type": "text",
          "value": "Control system in which the output has an effect on the input quantity in such a manner that the input quantity will adjust itself based on the output generated is called **closed loop control system**. **Open loop control system** can be converted in to closed loop control system by providing a feedback. Figure below shows the block diagram of closed loop control system in which feedback is taken from output and fed in to input."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/controller_2.png",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "text",
          "value": "**Practical example of Closed loop control system:**"
        },
        {
          "type": "text",
          "value": "1. Missile Launched and Auto Tracked by Radar ‚Äì The direction of missile is controlled by comparing the target and position of the missile.\n2. An Air Conditioner ‚Äì An air conditioner functions depending upon the temperature of the room.\n3. Cooling System in Car ‚Äì It operates depending upon the temperature which it controls."
        },
        {
          "type": "heading",
          "value": "Core topics in Control Theory"
        },
        {
          "type": "text",
          "value": "Before we design any controller, we have to consider the key factors that will drive the robot and how are we supposed to build the controller that will drive us to the best results which are also known as **control objectives**. These factors are listed below:"
        },
        {
          "type": "text",
          "value": "1.**Stability :** By this, we mean to measure the level of stability in the signal which will drive the object and also keep a check on the fluctuation of the signal. For eg. if we are making a cruise controller for a car, then the controller should give a stable signal after the car has reached the cruising speed and the speed should remain constant (no fluctuations)."
        },
        {
          "type": "text",
          "value": "2.**Tracking :** It is necessary to give controls after analyzing the response given due to the input signal. For instance, in a cruise controller, after setting up cruising speed, it is necessary for the controller to keep a regular check on the speed by which it can decide whether to accelerate or retard."
        },
        {
          "type": "text",
          "value": "3.**Robustness :** Robust control systems often incorporate advanced topologies which include multiple feedback loops and feed-forward paths. The control laws may be represented by high order transfer functions required to simultaneously accomplish desired disturbance rejection performance with robust closed loop operation. For example, the controller should not be hard coded to function only for a certain velocity ,say 50 miles/hour if designing a cruise control."
        },
        {
          "type": "text",
          "value": "4.**Disturbance :** It refers to the noise (not useful signal) that the controller might signal while sending or any sort of attenuation that can happen. It actually depends on the quality of instruments used in making a controller and also due to some external factors."
        },
        {
          "type": "text",
          "value": "5.**Optimality :** It is a set of differential equations that describe the paths of the control variables that minimize the cost function."
        },
        {
          "type": "heading",
          "value": "Laplace transform"
        },
        {
          "type": "text",
          "value": "The Laplace transform plays a important role in control theory. It appears in the description of linear time invariant systems, where it changes convolution operators into multiplication operators and allows to define the transfer function of a system. The properties of systems can be then translated into properties of the transfer function. It allows the use of graphical methods to predict system performance without solving the differential equations of the system. These include response, steady state behavior, and transient behavior."
        },
        {
          "type": "subheading",
          "value": "Laplace Vs Fourier transform"
        },
        {
          "type": "text",
          "value": "Laplace transform:<br>\n$F(s)=\\int_{0}^{\\infty}f(t)e^{-st}dt  \\qquad f^{'}(t)\\Rightarrow sF(s)$<br><br>\nFourier transform:<br>\n$F(\\omega) = \\int_{-\\infty}^{\\infty}f(t)e^{-j\\omega t}dt$<br><br>\nLaplace transforms often depend on the initial value of the function whereas Fourier transforms are independent of the initial value. The transforms are only the same if the function is the same both sides of the y-axis (so the unit step function is different)."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this",
              "url": "https://www.electrical4u.com/laplace-transformation/"
            }
          ]
        },
        {
          "type": "heading",
          "value": "Closed Loop Transfer Function"
        },
        {
          "type": "text",
          "value": "A **closed-loop transfer function** in control theory is a mathematical expression describing the net result of the effects of a closed feedback loop on the input signal to the circuits enclosed by the loop."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/controller_4.png",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "text",
          "value": "Where: block G represents the open-loop gains of the controller or system and is the forward path, and block H represents the gain of the sensor, transducer or measurement system in the feedback path."
        },
        {
          "type": "text",
          "value": "To find the transfer function of the closed-loop system above, we must first calculate the output signal Œ∏<sub>o</sub> in terms of the input signal Œ∏<sub>i</sub>. To do so, we can easily write the equations of the given block-diagram as follows."
        },
        {
          "type": "text",
          "value": "The output from the system is equal to:  Output = G x Error"
        },
        {
          "type": "text",
          "value": "Note that the error signal, Œ∏<sub>e</sub> is also the input to the feed-forward block: G"
        },
        {
          "type": "text",
          "value": "The output from the summing point is equal to:  Error = Input - H x Output"
        },
        {
          "type": "text",
          "value": "If H = 1 (unity feedback) then:"
        },
        {
          "type": "text",
          "value": "The output from the summing point will be:  Error (Œ∏<sub>e</sub>) = Input - Output"
        },
        {
          "type": "text",
          "value": "Eliminating the error term, then:"
        },
        {
          "type": "text",
          "value": "The output is equal to:  Output = G x (Input - H x Output)"
        },
        {
          "type": "text",
          "value": "Therefore:  G x Input = Output + G x H x Output"
        },
        {
          "type": "text",
          "value": "Rearranging the above gives us the closed-loop transfer function of:"
        },
        {
          "type": "image",
          "src": "/images/handbook/images/controller_5.png",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "heading",
          "value": "Controllability"
        },
        {
          "type": "image",
          "src": "/images/handbook/images/controlablity.png",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "image",
          "src": "/images/handbook/images/controlablity_1.jpg",
          "alt": "graph",
          "caption": "graph"
        },
        {
          "type": "heading",
          "value": "Types of Feedback Control"
        },
        {
          "type": "subheading",
          "value": "Positive Feedback"
        },
        {
          "type": "text",
          "value": "In a ‚Äúpositive feedback control system‚Äù, the set point and output values are added together by the controller as the feedback is ‚Äúin-phase‚Äù with the input. The effect of positive (or regenerative) feedback is to ‚Äúincrease‚Äù the systems gain, i.e, the overall gain with positive feedback applied will be greater than the gain without feedback]"
        },
        {
          "type": "subheading",
          "value": "Negative Feedback"
        },
        {
          "type": "text",
          "value": "In a ‚Äúnegative feedback control system‚Äù, the set point and output values are subtracted from each other as the feedback is ‚Äúout-of-phase‚Äù with the original input. The effect of negative (or degenerative) feedback is to ‚Äúreduce‚Äù the gain. As a rule negative feedback systems are more stable than positive feedback systems. Negative feedback also makes systems more immune to random variations in component values and inputs."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/whatis-feedback_loop_mobile.jpg",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this",
              "url": "https://www.electrical4u.com/types-of-systems-linear-and-non-linear-system/"
            }
          ]
        }
      ]
    },
    {
      "id": "pid-controller",
      "title": "PID Controller",
      "category": "automation",
      "excerpt": "PID control is the most popular technique used in industries because it is relatively easy and simple to design and implement.",
      "subcategory": "Control Theory",
      "content": [
        {
          "type": "heading",
          "value": "Linear Control Techniques"
        },
        {
          "type": "text",
          "value": "Linear Control technique is the most widely used technique for designing control systems in robotics because of its simple implementation when your system is operating in vicinity of a particular point. Some of the common linear control system design techniques, includes the well-known PID control, H<sub>2</sub> and H<sub>$\\infty$</sub> optimal control, linear quadratic regulator (LQR) with loop transfer recovery design (LTR) , and some newly developed design techniques, such as the robust and perfect tracking (RPT) method."
        },
        {
          "type": "heading",
          "value": "PID Controller"
        },
        {
          "type": "text",
          "value": "PID control is the most popular technique used in industries because it is relatively easy and simple to design and implement. Most importantly, it works in most practical situations, although its performance is somewhat limited owing to its restricted structure."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/Pid.jpg",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "text",
          "value": "Hence, a PID control law has the following general form for the input command:<br><br>\n$u(t) = K~p~e(t) + K~i~\\int e(t) + K~d~\\frac{de(t)}{dt}$<br><br>\nwhere $e = q - q~d~$ is the error signal, and $K~p~, K~i~$ and $K~d~$ are positive constant gains associated with proportional, integral, and derivative controllers."
        },
        {
          "type": "text",
          "value": "Consider the control system , in which G(s) is the plant to be controlled and K(s) is the PID controller, it can be characterized by the following transfer function:\n$K(s) = K~p~(1+\\frac{1}{Tis}+Tds)$\nThe control system design is then to determine the parameters K<sub>p</sub> , T<sub>i</sub> and T<sub>d</sub> such that the resulting dosed-loop system yields a certain desired performance, i.e. it meets certain prescribed design specifications."
        },
        {
          "type": "subheading",
          "value": "Proportional factor"
        },
        {
          "type": "text",
          "value": "The proportional factor is easiest to understand: The output of the proportional factor is the product of gain and measured error Œµ. Hence, larger proportional gain or error makes for greater output from the proportional factor. Setting the proportional gain too high causes a controller to repeatedly overshoot the setpoint, leading to oscillation."
        },
        {
          "type": "text",
          "value": "The downside to a proportional-only loop is that when error becomes too small, loop output becomes negligible. Therefore, even when the proportional loop reaches steady state, there is still error. The larger the proportional gain, the smaller the steady state error ‚Äî but the larger the proportional gain, the more likely the loop is to become unstable. This dilemma leads to inevitable steady-state error called *offset*."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/propotional.png",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "subheading",
          "value": "Integral Factor"
        },
        {
          "type": "text",
          "value": "The main function of an integral control is to eliminate the steady state error and make the system follow the set point at steady state conditions. The integral controller leads to an increasing control command for a positive error, and a decreasing control command for a negative error. The downside to the integral factor is that it strongly contributes to controller output overshoot past the target setpoint. The shorter the integral time, the more aggressively the integral works."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/integral.png",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "subheading",
          "value": "Derivative Factor"
        },
        {
          "type": "text",
          "value": "The purpose of derivative control is to improve the closed-loop stability of a system. A derivative controller has a predicting action by extrapolating the error using a tangent to the error curve. The derivative factor is the least understood and used of the three factors. In fact, a majority of PID loops in the real world are really just PI loops. A properly used derivative allows for more aggressive proportional and integral factors."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/derivative.png",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "heading",
          "value": "PID Tuning Method"
        },
        {
          "type": "text",
          "value": "The determination of corresponding PID parameter values for getting the optimum performance from the process is called tuning. This is obviously a crucial part in case of all closed loop control systems. There are number of tuning methods have been introduced to obtain fast and acceptable performance."
        },
        {
          "type": "subheading",
          "value": "Trial and Error Method"
        },
        {
          "type": "text",
          "value": "This is the simple method of tuning a PID controller. Once we get the clear understanding of PID parameters, the trial and error method become relatively easy."
        },
        {
          "type": "text",
          "value": "- Set integral and derivative terms to zero first and then increase the proportional gain until the output of the control loop oscillates at a constant rate. This increase of proportional gain should be in such that response the system becomes faster provided it should not make system unstable.\n- Once the P-response is fast enough, set the integral term, so that the oscillations will be gradually reduced. Change this I-value until the steady state error is reduced, but it may increase overshoot.\n- Once P and I parameters have been set to a desired values with minimal steady state error, increase the derivative gain until the system reacts quickly to its set point. Increasing derivative term decreases the overshoot of the controller response."
        },
        {
          "type": "subheading",
          "value": "Zeigler-Nichols Method"
        },
        {
          "type": "text",
          "value": "It is another popular method for tuning PID controllers. Ziegler and Nichols presented two classical methods for determining values of proportional gain, integral time and derivative time based on transient response characteristics of a given plant or system."
        },
        {
          "type": "text",
          "value": "#### First Method"
        },
        {
          "type": "text",
          "value": "- Obtain a unit step response of the plant experimentally and it may look‚Äòs‚Äô shaped curve as shown in figure below. This method applies, if obtained response exhibit s-shaped curve for unit step input otherwise it cannot be applied. This curve can also be obtained by dynamic simulation of the plant."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/tuning_1.png",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "text",
          "value": "- Obtain two constants, delay time L and time constant T by drawing a tangent line at the inflection point of the s-shaped curve.\n- Set the parameters of K<sub>p</sub>, T<sub>i</sub> , and T<sub>d<sub> values from the table given below for three types of controllers."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/tuning_2.png",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "text",
          "value": "#### Second Method"
        },
        {
          "type": "text",
          "value": "- It is very similar to the trial and error method where integral and derivative terms are set to the zero, i.e., making Ti infinity and Td zero.\n- Increase the proportional gain such that the output exhibits sustained oscillations. If the system does not produce sustained oscillations then this method cannot be applied. The gain at which sustained oscillations produced is called as critical gain."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/tuning_3.png",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "text",
          "value": "- Once the sustain oscillations are produced, set the values of Ti and Td as per the given table for P, PI and PID controllers based on critical gain and critical period."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/tuning_4.png",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this",
              "url": "https://www.youtube.com/watch?v=3yU2k8R9JeU&t=308s"
            }
          ]
        }
      ]
    },
    {
      "id": "lqr-controller",
      "title": "Linear Quadratic Regulator (LQR)",
      "category": "automation",
      "excerpt": "LQR is an optimal control technique that minimizes a quadratic cost function for linear systems.",
      "subcategory": "Control Theory",
      "content": [
        {
          "type": "heading",
          "value": "Linear-Quadratic Regulator(LQR) Controller"
        },
        {
          "type": "text",
          "value": "The theory of optimal control is concerned with operating a dynamic system at minimum cost. The case where the system dynamics are described by a set of linear differential equations and the cost is described by a quadratic function is called the LQ problem. One of the main results in the theory is that the solution is provided by the **linear‚Äìquadratic regulator** (**LQR**)."
        },
        {
          "type": "text",
          "value": "The settings of a (regulating) controller governing either a machine or process (like an airplane or chemical reactor) are found by using a mathematical algorithm that minimizes a cost function with weighting factors needed to be supplied. A **cost function** is a function that maps an event or values of one or more variables onto a real number intuitively representing some \"cost\" associated with the event. The cost function is often defined as a sum of the deviations of key measurements, like altitude or process temperature, from their desired values. The algorithm thus finds those controller settings that minimize undesired deviations. The magnitude of the control action itself may also be included in the cost function."
        },
        {
          "type": "heading",
          "value": "Finite horizon LQR"
        },
        {
          "type": "text",
          "value": "For a continuous-time linear system, defined on $t \\epsilon [t_0,t_1]$ , described by:<br><br>\n$\\dot{x} = Ax + Bu$<br><br>"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "Riccati differential equation",
              "url": "https://en.wikipedia.org/wiki/Riccati_differential_equation"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this",
              "url": "https://www.youtube.com/watch?v=1_UobILf3cc&list=RDCMUCm5mt-A4w61lknZ9lCsZtBw&start_radio=1&t=7"
            }
          ]
        },
        {
          "type": "heading",
          "value": "Linear Quadratic Gaussian (LQG) control theory"
        },
        {
          "type": "text",
          "value": "Here, Given a linear model of the plant in a statespace description, and assuming that the disturbance and measurement noise are Gaussian stochastic processes with known power spectral densities, the designer translates the design specifications into a quadratic performance criterion consisting of some state variables and control signal inputs. The object of design then is to minimize the performance criterion by using appropriate state or measurement feedback controllers while guaranteeing the closed-loop stability. When LQG controller problem is solved in a deterministic setting, known as an  H<sub>2</sub> optimal control problem, in which the H<sub>2</sub> norm of a certain transfer function from an exogenous disturbance to a pertinent controlled output of a given plant is minimized by appropriate use of an internally stabilizing controller."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this",
              "url": "https://www.youtube.com/watch?v=7OZVbqPQ2Zw"
            }
          ]
        },
        {
          "type": "text",
          "value": "**H‚àû** (i.e. \"**H-infinity**\") **methods** are used in control theory to synthesize controllers to achieve stabilization with guaranteed performance. To use *H*‚àû methods, a control designer expresses the control problem as a mathematical optimization problem and then finds the controller that solves this optimization. *H*‚àû techniques have the advantage over classical control techniques in that *H*‚àû techniques are readily applicable to problems involving multivariate systems with cross-coupling between channels."
        },
        {
          "type": "text",
          "value": "Read [this]() material from MIT Open Courseware  to know about H‚àû methods in more detail."
        }
      ]
    },
    {
      "id": "mpc-controller",
      "title": "Model Predictive Control (MPC)",
      "category": "automation",
      "excerpt": "MPC is an advanced control method that uses a model to predict future system behavior.",
      "subcategory": "Control Theory",
      "content": [
        {
          "type": "heading",
          "value": "Model Based Controllers"
        },
        {
          "type": "text",
          "value": "Model-based control uses information about the dynamics of the system's structure and its behavior in time to obtain a better control result regarding stability and performance of the controlled system. Take the following simple example:"
        },
        {
          "type": "text",
          "value": "Let $\\frac{d^2x}{dt^2}= f(x)+u$"
        },
        {
          "type": "text",
          "value": "be the system to be controlled, where x - state vector, f(x) - nonlinear vector function, u - control vector. Suppose we have some estimation est(x) than we use a control law like <br><br>\n$u = -est(x)+u_{st}$<br><br>\nwhere u<sub>st</sub> be some maybe linear PID control law<br><br>\n$u_{st} = K_px + K_d\\frac{dx}{dt} + K_i\\int xdt$<br><br>\nSo we get<br><br>\n$\\frac{d^2x}{dt^2} = \\Delta f + K_px + K_d\\frac{dx}{dt} + K_i\\int xdt$<br><br>\nwhere <br><br>\n$\\Delta f =f(x) - est(x)$<br><br>\nIf the model uncertainties are small enough we get a linear system with a disturbance Delta f which can be stabilized using appropriate control gains K<sub>p</sub>, K<sub>d</sub>, K<sub>I</sub>. Above given is just an example of model based controller in real life model based controller are way more complex than this."
        },
        {
          "type": "text",
          "value": "**Model Predictive Control(MPC)** is the most widely known model based controller. Model Predictive Controllers rely on the dynamic models of the process, most often linear empirical models obtained by system identification."
        },
        {
          "type": "text",
          "value": "Model predictive control offers several important advantages:"
        },
        {
          "type": "text",
          "value": "(1) the process model captures the dynamic and static interactions between input, output, and disturbance variables,"
        },
        {
          "type": "text",
          "value": "(2) constraints on inputs and outputs are considered in a systematic manner,"
        },
        {
          "type": "text",
          "value": "(3) the control calculations can be coordinated with the calculation of optimum set points, and"
        },
        {
          "type": "text",
          "value": "(4) accurate model predictions can provide early warnings of potential problems."
        },
        {
          "type": "text",
          "value": "The mathematics and concepts involved in MPC are a bit complex and require a decent understanding of mathematics of control theory."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this",
              "url": "http://folk.ntnu.no/skoge/vgprosessregulering/papers-pensum/seborg-c20ModelPredictiveControl.pdf"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this",
              "url": "https://www.youtube.com/watch?v=YwodGM2eoy4"
            }
          ]
        },
        {
          "type": "text",
          "value": "Some of the other resources you should check to understand control theory and various controllers in more detail are:"
        },
        {
          "type": "text",
          "value": "1. Control Bootcamp [playlist](https://www.youtube.com/playlist?list=PLMrJAkhIeNNR20Mz-VpzgfQs5zrYi085m) by Steve Brunton\n2. Control Systems [Lectures](https://www.youtube.com/user/ControlLectures) by Brian Douglas\n3. Control of Mobile Robots [course](https://www.my-mooc.com/en/mooc/control-of-mobile-robots/) by Georgia Tech University on Coursera\n4. Modern Robotics - Mechanical, Planning and Control by Kevin.M.Lynch and Frank.C.Park\n5. MIT Courseware Control Theory [Notes](https://ocw.mit.edu/courses/mechanical-engineering/2-017j-design-of-electromechanical-robotic-systems-fall-2009/lecture-notes/MIT2_017JF09_control.pdf)"
        }
      ]
    },
    {
      "id": "electronics-intro",
      "title": "Introduction to Electronics",
      "category": "electronics",
      "excerpt": "Overview of electronics in robotics - processing units, sensors, and interfacing components.",
      "content": [
        {
          "type": "heading",
          "value": "Introduction"
        },
        {
          "type": "text",
          "value": "From interfacing microprocessors to making logical circuits, Robotics is incomplete without electronics. Every task that a Robot performs at the end eventually boils down to some signal received by it. \nElectronics for any robotics projects involves tasks like setting up the power source, interfacing sensors, setting up the computation unit, etc."
        },
        {
          "type": "text",
          "value": "Most of the Robots have a processing unit on them which collects data from sensors and peforms all the calculations for determining the steps that the robot needs to peform. Some of the popular processing units used for robots are Raspberry Pi, Nvidia Jetson, Arduino, etc."
        },
        {
          "type": "text",
          "value": "Sensors are the medium through which any robot interacts with its environment. Some of the common sensor we can see in robots are depth cameras, LIDAR, Encoders, IMU, etc."
        }
      ]
    },
    {
      "id": "arduino",
      "title": "Arduino",
      "category": "electronics",
      "excerpt": "Arduino is a very accessible and easy to program microcontroller, great for beginners in robotics.",
      "subcategory": "Development Boards",
      "content": [
        {
          "type": "heading",
          "value": "Arduino"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "This",
              "url": "https://www.youtube.com/watch?v=CqrQmQqpHXc"
            },
            {
              "name": "video",
              "url": "https://www.youtube.com/watch?v=CqrQmQqpHXc"
            }
          ]
        },
        {
          "type": "heading",
          "value": "Arduino Board Layout"
        },
        {
          "type": "image",
          "src": "/images/handbook/images/arduino1.png",
          "alt": "arduino",
          "caption": "arduino"
        },
        {
          "type": "text",
          "value": "The above diagram shows an Arduino UNO board with all the parts labelled and explained below:"
        },
        {
          "type": "text",
          "value": "1.  **USB Port:** Arduino can be powered by connecting it to your computer using a USB cable. It is also used for uploading code and communicating via the serial port.\n2.  **Power Jack:** Used to power an arduino directly from a wall adaptor.\n3.  **Voltage Regulator:** Controls and stabilises the voltage used by the Arduino and its components.\n4.  **Crystal Oscillator:** A microcontroller is a clock based device. The crystal oscillator present on the arduino generates a clock of frequency 16MHz.\n5.  **Reset controllers:** Resetting the arduino board starts the execution of a program from the beginning. Arduino can be reset in 2 ways : by pressing the reset button (17) and sending a 0V signal to the RESET pin (5).\n6.  **3.3V power**\n7.  **5V power**\n8.  **GND (0V)**\n9.  **VIN:** This pin can be used to power the arduino board from an external power source, from 7-20V.\n10.  **Analog Pins:** These pins (labeled A0-A5) can be used to read continuous analog values (between 0 and 5V). They are often used to interface the Arduino with analog sensors.\n11.  **Main Microcontroller:** This IC is the main microcontroller, that executes the code you program it with.\n12.  **ICSP Pin:** Can be used to program the arduino board‚Äôs firmware. For advanced users only.\n13.  **Power LED indicator:** Indicates whether the board is powered up correctly.\n14.  **TX/RX LEDs:** The TX/RX pins flash to indicate transfer/receival of serial data between the computer and Arduino.\n15.  **Digital I/O Pins: ¬†**These pins can be programmed as input/output pins. When used as output, they can be set HIGH (+5V) or LOW (0V).\n16.  **Analog Reference(AREF):** Can be used to set an external reference voltage(0-5V) as the upper limit for analog input pins.\n17.  **Reset Button:** Pressing it causes the Arduino to restart its code."
        },
        {
          "type": "heading",
          "value": "The Blink Sketch"
        },
        {
          "type": "text",
          "value": "The Blink sketch is like the ‚ÄúHello World‚Äù program in the Arduino world. It simply consists of blinking the onboard LED (labeled ‚ÄòL‚Äô). No actual circuit connections are required!"
        },
        {
          "type": "image",
          "src": "/images/handbook/images/arduino2.png",
          "alt": "arduino2",
          "caption": "arduino2"
        },
        {
          "type": "subheading",
          "value": "Code"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "here",
              "url": "https://github.com/schacon/blink/blob/master/blink.ino"
            }
          ]
        },
        {
          "type": "heading",
          "value": "How to code an Arduino in Arduino IDE"
        },
        {
          "type": "text",
          "value": "1.  Download and install Arduino Software (IDE) from [here](https://www.arduino.cc/en/main/software). The Integrated Development Environment (IDE) is a common coding environment for all arduino boards.\n2.  Open the IDE and a new sketch will open up which would look like the image below. Sketch is just a name arduino uses for a program.\n3.  Then just paste the entire code here.\n4.  Now connect your Arduino UNO board to your PC using an A B USB cable and select the option \"Arduino/Genuino Uno\" under **Tools > Board** menu. Also make sure to select the correct port through which the PC is connected to the board under **Tools > Port** menu.\n5.  Click on the \"tick\" button in upper left corner to compile the code and check for errors. After resolving any and all errors click on the \"arrow\" button next to it to upload the code to the board.\n6.  After successful upload the Arduino Uno will start executing the code while drawing power from the PC through the USB cable."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/arduinoide.png",
          "alt": "arduinoide",
          "caption": "arduinoide"
        },
        {
          "type": "subheading",
          "value": "Explanation"
        },
        {
          "type": "text",
          "value": "Every Arduino sketch **must** have two particular functions:"
        },
        {
          "type": "text",
          "value": "1.  void setup()\n    1.  The setup() function is called when a sketch starts and will only run once, after each powerup or reset of the Arduino board.\n2.  void loop()\n    1.  This function does precisely what its name suggests, that is loops consecutively, allowing your program to change and respond. Whatever code you write inside loop() will keep running as long as the Arduino is receiving power."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "Blink",
              "url": "https://github.com/schacon/blink/blob/master/blink.ino"
            }
          ]
        },
        {
          "type": "code",
          "language": "cpp",
          "value": "int led = 13;"
        },
        {
          "type": "text",
          "value": "This line assigns a name to the pin that the LED is attached to, i.e. pin 13."
        },
        {
          "type": "text",
          "value": "Then we have the setup() function, which runs only once. It includes the following line."
        },
        {
          "type": "code",
          "language": "cpp",
          "value": "pinMode(led, OUTPUT);"
        },
        {
          "type": "text",
          "value": "This tells the Arduino to configure that pin as an output."
        },
        {
          "type": "text",
          "value": "Then we have the following loop() function."
        },
        {
          "type": "code",
          "language": "cpp",
          "value": "void loop()\n{\n  digitalWrite(led, HIGH);  // turn the LED on (HIGH is the voltage level)\n  delay(1000);               // wait for a second\n  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW\n  delay(1000);              // wait for a second\n}"
        },
        {
          "type": "text",
          "value": "The digitalWrite() function tells a pin to either switch on (HIGH, or +5V) or off (LOW, or 0V).¬† The delay() function tells the Arduino to wait for a specified number of milliseconds."
        },
        {
          "type": "heading",
          "value": "Reading Analog Values"
        },
        {
          "type": "text",
          "value": "The following circuit reads the voltage from a potentiometer and sends it via USB to the serial port."
        },
        {
          "type": "subheading",
          "value": "Schematic"
        },
        {
          "type": "image",
          "src": "/images/handbook/images/arduinopot.png",
          "alt": "arduinopot",
          "caption": "arduinopot"
        },
        {
          "type": "subheading",
          "value": "Code"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "here",
              "url": "https://create.arduino.cc/example/builtin/01.Basics%5CAnalogReadSerial/AnalogReadSerial/preview"
            }
          ]
        },
        {
          "type": "subheading",
          "value": "Explanation"
        },
        {
          "type": "text",
          "value": "Whenever the serial port is to be used, it should be initialised with the following line _inside_ void setup(). The 9600 refers to the communication speed in bits-per-second."
        },
        {
          "type": "code",
          "language": "cpp",
          "value": "Serial.begin(9600);"
        },
        {
          "type": "text",
          "value": "The analogRead function reads the voltage at an analog pin and linearly converts it to a value between 0 and 1023. The Serial.println() function prints a variable to the serial monitor, followed by a newline (using Serial.print() to print data without the newline). The delay(1) is to limit the amount of data printed to the serial monitor."
        },
        {
          "type": "heading",
          "value": "References"
        },
        {
          "type": "text",
          "value": "1. For more lessons and material on Arduino, check out the QSTP - [Introduction to Mechatronics](https://github.com/ERC-BPGC/QSTP-Introduction-to-Mechatronics/tree/master/Module%201%20-%20Electronics%20and%20Arduino), designed by ERC.\n2. For some more detailed tutorials do read the documentation of [Arduino](https://www.arduino.cc/en/Tutorial/HomePage).\n3. For some video tutorials check out Jeremy Blum's [playlist](https://www.youtube.com/playlist?list=PLA567CE235D39FA84) for Arduino.\n4. For more DIY project ideas and inspirations check out [Great Scott's](https://www.youtube.com/c/greatscottlab/featured) youtube channel.\n5. To read more about the projects made by people using Arduino, check out Arduino's [blog](https://blog.arduino.cc/) as well."
        }
      ]
    },
    {
      "id": "esp32",
      "title": "ESP32",
      "category": "electronics",
      "excerpt": "ESP32 is a powerful WiFi and Bluetooth enabled microcontroller.",
      "subcategory": "Development Boards",
      "content": [
        {
          "type": "heading",
          "value": "ESP32"
        },
        {
          "type": "heading",
          "value": "Introduction"
        },
        {
          "type": "text",
          "value": "ESP32 is a series of feature-rich MCU with integrated Wi-Fi and Bluetooth connectivity for a wide range of applications. Espressif Systems, China, produce it.ESP32 is cheap and nearly ten times faster than Arduino Uno and is a 32-bit versatile device.\nDevelopers of ESP32 IC made a small module board with edge castellations. One popular version of such a module board is called ESP-WROOM-32. It is a dual-core, 32-bit microcontroller unit, and all the cores can be controlled individually. It has integrated Wi-Fi, Bluetooth, and Bluetooth Low Energy with multiple digital and analog I/O pins."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/esp32intro2.jpg",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "heading",
          "value": "Comparison Of ESP32 and Arduino Uno"
        },
        {
          "type": "text",
          "value": "| Parameter              | ESP32 | ARDUINO UNO |\n|------------------------|---------------------------|-------------|\n| Processor              | Xtensa dual-core             | ATMega328P  |\n|Number of Cores| 2 | 1 | \n|Architecture| 32 bit | 8 bit |\n| Operating Voltage|2.2 to 3.6V |5V|\n|CPU Frequency|160 or 240 MHz|16 MHz|\n|WiFi| YES | NO |\n|Bluetooth| YES | NO |\n|RAM| 512 KB | 2 KB| \n|Flash| 16 MB | 32 KB|\n|GPIO pins| 36 | 14|\n|Busses| SPI,I¬≤C,UART,I2S,CAN | SPI,I¬≤C,UART |\n|ADC Pins| 18 | 6 |\n|DAC Pins| 2 | 0 |\n|USB Conector|Micro|Type B|\n|UART|3|1|\n|SPI|3|1|\n|I¬≤C|2|1|"
        },
        {
          "type": "heading",
          "value": "Pinout"
        },
        {
          "type": "image",
          "src": "/images/handbook/images/ESP32pinout.png",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "manual",
              "url": "https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_en.pdf "
            }
          ]
        },
        {
          "type": "heading",
          "value": "Peripherals and Features"
        },
        {
          "type": "text",
          "value": "Now that we have seen the ESP32 Pinout , let us now focus on some of the important peripherals of ESP32 and their associated pins. ESP32 Microcontroller has:"
        },
        {
          "type": "text",
          "value": "* Up to 18 12-bit Analog to Digital converters.\n* 2, 8-bit Digital to Analog converters.\n* 10 capacitive touch switch sensors.\n* 4 SPI channels.\n* 2 I¬≤C interfaces.\n* 2 I2S interfaces (for digital audio).\n* 3 UARTs for communications.\n* Up to 8 channels of IR remote control.\n* Up to 16 channels of LED PWM (pulse width modulation).\n* An integrated Hall-effect sensor.\n* An ultra-low-power analog preamp.\n* An internal low-dropout regulator."
        },
        {
          "type": "text",
          "value": "* ### GPIO\n34 pins, each pin carries out more than one function ( only one will be active). You can configure a pin as either a GPIO or an ADC or an UART in the program.ADC and DAC pins are predefined, and you have to use the manufacturer specified pins. But other functions like PWM, SPI, UART, I2C etc. can be assigned to any GPIO pin through the program."
        },
        {
          "type": "text",
          "value": "* ### RTC GPIO\npart of the RTC Low-Power subsystem. These pins can be used to wake ESP32 from a deep sleep as an external wake-up source."
        },
        {
          "type": "text",
          "value": "* ### ADC\nESP32 has two 12-bit SAR Analog to Digital Converter Modules with 8-channels and 10-channels each. So, ADC1 and ADC2 blocks combined together have 18 channels of 12-bit ADC.With 12-bit resolution, the Digital output values will be in the range of 0 ‚Äì 4093."
        },
        {
          "type": "text",
          "value": "* ### DAC\nESP32 Microcontroller has two independent 8-bit Digital to Analog Converter channels to convert digital values to analog voltage signals. The DAC has an internal resistor network and uses a power supply as an input reference voltage.\nThe following two GPIO Pins are associated with DAC functionalities."
        },
        {
          "type": "text",
          "value": "1. DAC1 ‚Äî GPIO25\n   2. DAC2 ‚Äî GPIO26"
        },
        {
          "type": "text",
          "value": "* ### Capacitive Touch GPIOs\n can detect variations in capacitance on a pin due to touching or approaching the GPIO Pin with a finger or stylus. These Touch GPIOs can be used in implementing capacitive touch pads without any additional hardware."
        },
        {
          "type": "text",
          "value": "* ### SPI\nthree SPI blocks (SPI, HSPI and VSPI) are present in both master and slave modes. SPI is used to interface with Flash Memory. So, you have two SPI interfaces."
        },
        {
          "type": "text",
          "value": "* ### I¬≤C\nThere are two I2C interfaces in ESP32 with complete flexibility on assigning pins, i.e., SCL and SDA pins for both I2C interfaces can be assigned in the program by the user.If you are using Arduino IDE, then the default I2C pins are:\nSDA ‚Äì GPIO21\nSCL ‚Äì GPIO22"
        },
        {
          "type": "text",
          "value": "* ### PWM\nThe PWM Controller in ESP32 has 16 independent PWM waveform channels with configurable frequency and duty cycle. The PWM waveform can be used to drive motors and LEDs. You can configure the PWM signal frequency, channel, GPIO pin and also the duty cycle."
        },
        {
          "type": "heading",
          "value": "How To Program ESP32"
        },
        {
          "type": "text",
          "value": "One can use C++ and MicroPython to program the ESP32. It supports multiple programming environments :"
        },
        {
          "type": "text",
          "value": "* Arduino IDE\n* PlatformIO IDE (VS Code)\n* LUA\n* MicroPython\n* Espressif IDF (IoT Development Framework)\n* JavaScript"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "here",
              "url": "https://docs.espressif.com/projects/esp-idf/en/stable/esp32/index.html"
            }
          ]
        },
        {
          "type": "heading",
          "value": "Using the Arduino IDE"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this",
              "url": "https://www.electronicshub.org/esp32-arduino-ide/"
            }
          ]
        },
        {
          "type": "heading",
          "value": "LED Blink Sketch"
        },
        {
          "type": "image",
          "src": "/images/handbook/images/ledblink.png",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "here",
              "url": "https://dronebotworkshop.com/esp32-intro/ "
            }
          ]
        },
        {
          "type": "heading",
          "value": "References"
        },
        {
          "type": "text",
          "value": "* [Video](https://youtu.be/xPlN_Tk3VLQ) on Introduction to ESP 32-Getting Started by DroneBot Workshop \n* For more details you can refer to the website of DroneBot Workshop [here](https://dronebotworkshop.com/esp32-intro/).\n* ESP 32 [webpage](https://www.electronicshub.org/esp32-pinout/) by Electronics Hub \n* Programming Guide to ESP 32 by [Electronics Hub](https://www.electronicshub.org/esp32-arduino-ide/) and [OpenLab](https://openlabpro.com/guide/led-blinking-on-esp32/).\n* Espressif Systems [documentation](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/index.html)\n on ESP 32 ."
        }
      ]
    },
    {
      "id": "stm32",
      "title": "BluePill (STM32F103C8T6)",
      "category": "electronics",
      "excerpt": "STM32 is a family of powerful ARM Cortex-M microcontrollers.",
      "subcategory": "Development Boards",
      "content": [
        {
          "type": "heading",
          "value": "Blue Pill (STM32F103C8T6)"
        },
        {
          "type": "heading",
          "value": "Introduction"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "This",
              "url": "https://www.youtube.com/watch?v=EaZuKRSvwdo"
            }
          ]
        },
        {
          "type": "image",
          "src": "/images/handbook/images/bluepill_intro.jpeg",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "heading",
          "value": "Naming Convention of STM microcontrollers </br>"
        },
        {
          "type": "text",
          "value": "|**Parameter**|**Meaning**|\n|---------|-------|\n|STM| name of the manufacturer (STMicroelectronics)| </br>\n|32| 32 bit ARM architecture |</br>\n|F|Foundation |</br>\n|1| Core (ARM Cortex M3)| </br>\n|03| Line (describes peripherals and speed) </br>\n|C| 48 pins </br>\n|8|64 KB flash memory</br>\n|T|LQFP package (Low Profile Quad Flat Pack) </br>\n|6|Operating Temperature Range (-40 ¬∞C to 85 ¬∞C) </br>"
        },
        {
          "type": "heading",
          "value": "Technical Specifications of STM32 </br>"
        },
        {
          "type": "text",
          "value": "|**Parameter**|**Meaning**|\n|---------|-------|\n|Architecture|32 bit ARM Cortex M3 </br>\n|Operating Voltage| 2.7V to 3.6V </br>\n|CPU Frequency | 72 MHz </br>\n|Number of GPIO pins| 37 </br>\n|Number of PWM pins| 12 </br>\n |Analog Input Pins| 10 (12 bit resolution) </br>\n |I2C Peripherals| 2 </br>\n |SPI Peripherals| 2 </br>\n |CAN 2.0 Peripheral|1| </br>\n |Timers | 3(16-bit), 1| (PWM) </br>\n |Flash Memory| 64KB |</br>\n|RAM| 20kB |</br>"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "official datsheet",
              "url": "https://www.st.com/resource/en/datasheet/stm32f103c8.pdf"
            },
            {
              "name": "reference manual",
              "url": "https://www.st.com/content/ccc/resource/technical/document/reference_manual/59/b9/ba/7f/11/af/43/d5/CD00171190.pdf/files/CD00171190.pdf/jcr:content/translations/en.CD00171190.pdf"
            }
          ]
        },
        {
          "type": "heading",
          "value": "Pinout"
        },
        {
          "type": "image",
          "src": "/images/handbook/images/STM32-Pin-Details_0.png",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "heading",
          "value": "Programming STM32 </br>"
        },
        {
          "type": "subheading",
          "value": "1) Using STM32duino bootloader (Arduino IDE)"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "This",
              "url": "https://maker.pro/arduino/tutorial/how-to-program-the-stm32-blue-pill-with-arduino-ide"
            }
          ]
        },
        {
          "type": "subheading",
          "value": "2) Using Keil UVision and STM32CubeMX"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this",
              "url": "https://www.electronicshub.org/program-stm32f103c8t6-using-keil-uvision/"
            }
          ]
        }
      ]
    },
    {
      "id": "stm32-vs-arduino",
      "title": "Arduino vs STM32",
      "category": "electronics",
      "excerpt": "Comparison between Arduino and STM32 microcontrollers.",
      "subcategory": "Development Boards",
      "content": [
        {
          "type": "heading",
          "value": "Comparison between STM32F103C8T6 and Arduino UNO"
        },
        {
          "type": "text",
          "value": "| Parameter              | STM32F103C8T6 (Blue Pill) | Arduino UNO |\n|------------------------|---------------------------|-------------|\n| Processor              | STM32F103C8T6             | ATMega328P  |\n| Operating Voltage|3.3V|5V|\n|CPU Speed|72 MHz|16 MHz|\n|Analog pins|10|8|\n|Digital I/O or PWM|37|14|\n|EEPROM/SRAM (KB)|NA/20|1/2|\n|Flash Memory|64/128 KB|32 KB|\n|USB Conector|Micro|Type B|\n|UART|3|1|\n|SPI|2|1|\n|I¬≤C|2|1|"
        }
      ]
    },
    {
      "id": "pyboard",
      "title": "Pyboard - MicroPython",
      "category": "electronics",
      "excerpt": "Pyboard runs MicroPython, making it easy to program microcontrollers with Python.",
      "subcategory": "Development Boards",
      "content": [
        {
          "type": "heading",
          "value": "Pyboard - MicroPython"
        },
        {
          "type": "text",
          "value": "MicroPython is an implementation of the Python 3 programming language which is optimized to run on many microcontrollers. It has modules to access the hardware of the microcontroller, and the code is compatible to a great extent with normal python code."
        },
        {
          "type": "text",
          "value": "The Pyboard is the official MicroPython microcontroller board based on a STM3F405RG microcontroller."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/pyboard1.jpg",
          "alt": "pyboard1",
          "caption": "pyboard1"
        },
        {
          "type": "heading",
          "value": "Pyboard Board Layout"
        },
        {
          "type": "image",
          "src": "/images/handbook/images/pyboard2.jpg",
          "alt": "pyboard2",
          "caption": "pyboard2"
        },
        {
          "type": "text",
          "value": "The hardware has:"
        },
        {
          "type": "text",
          "value": "1. STM32F405RG microcontroller\n2. 168 MHz Cortex M4 CPU with hardware floating point\n3. 1024KiB flash ROM and 192KiB RAM\n4. Micro USB connector for power and serial communication\n5. Micro SD card slot, supporting standard and high capacity SD cards\n6. 3-axis accelerometer (MMA7660)\n7. Real time clock with optional battery backup\n8. 24 GPIO on left and right edges and 5 GPIO on bottom row, plus LED and switch GPIO available on bottom row\n9. 3x 12-bit analog to digital converters, available on 16 pins, 4 with analog ground shielding\n10.\t2x 12-bit digital to analog (DAC) converters, available on pins X5 and X6\n11.\t4 LEDs (red, green, yellow and blue)\n12.\t1 reset and 1 user switch\n13.\tOn-board 3.3V LDO voltage regulator, capable of supplying up to 250mA, input voltage range 3.6V to 16V\n14.\tDFU bootloader in ROM for easy upgrading of firmware"
        },
        {
          "type": "heading",
          "value": "Blink Sketch"
        },
        {
          "type": "text",
          "value": "Similar to the blink sketch with Arduino, we can make a simple blink sketch with Pyboard using MicroPython."
        },
        {
          "type": "subheading",
          "value": "Code"
        },
        {
          "type": "text",
          "value": "You can copy the code from here:"
        },
        {
          "type": "code",
          "language": "text",
          "value": "import pyb\nled = pyb.LED(4)\nwhile True:\n  led.on()\n  pyb.delay(1000)\n  led.off()\n  pyb.delay(1000)"
        },
        {
          "type": "subheading",
          "value": "How to Code"
        },
        {
          "type": "text",
          "value": "1.\tFirst connect the Pyboard to your computer using a USB. It will open up as a USB flash device with a boot python file and main python file."
        },
        {
          "type": "text",
          "value": "There are multiple ways to code a MicroPython program and run it on Pyboard."
        },
        {
          "type": "text",
          "value": "2.\tOne beginner friendly way is to use a serial communication program like putty, which opens the interactive REPL prompt and now you can execute commands directly.\nFollow this [tutorial](https://learn.adafruit.com/micropython-basics-how-to-load-micropython-on-a-board/serial-terminal) to setup putty."
        },
        {
          "type": "text",
          "value": "**NOTE:** you have to press delete after the indented at the end of the while loop to end the indented block and then only will the loop start running. To exit out of the while loop, use ctrl+c."
        },
        {
          "type": "text",
          "value": "3.\tAnother way is to run scripts from the built-in file system. Write to the main python file script using any text editor, save and close it. Make sure you eject the Pyboard USB drive and then only press the reset button on the PyBoard. You can use putty as a serial monitor."
        },
        {
          "type": "heading",
          "value": "References"
        },
        {
          "type": "text",
          "value": "1. For documentation and quick reference, check out the [official MicroPython website](https://micropython.org/).\n2. For a quick introduction to MicroPython and Pyboard, check out [this](https://www.youtube.com/watch?v=5LbgyDmRu9s) video.\n3. For a comparison with the Arduino, check out [this](https://www.youtube.com/watch?v=CyrgzzxQPzk) video.\n4. To discuss all things related to MicroPython with an online community check out the [MicroPython Forum](https://forum.micropython.org/)."
        }
      ]
    },
    {
      "id": "breadboard",
      "title": "Breadboard",
      "category": "electronics",
      "excerpt": "Understanding breadboards for prototyping electronic circuits.",
      "subcategory": "Basic Components",
      "content": [
        {
          "type": "heading",
          "value": "Breadboards"
        },
        {
          "type": "text",
          "value": "The breadboard is the most fundamental tool for electronics prototyping. They are great for creating temporary circuits and require absolutely no soldering."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/breadboardmain.jpg",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "heading",
          "value": "How to use a breadboard"
        },
        {
          "type": "text",
          "value": "A solderless breadboard consists of several holes, where wires or leads of electrical can be inserted. Each row of 5 holes is electrically connected by metal clips hidden underneath the surface."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/bbcontacts.jpg",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "text",
          "value": "Thus, one can connect two components by inserting them into holes of the same row. ICs can be inserted across the central ridge, and connections made as shown below."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/bbic.jpg",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "text",
          "value": "On either side of the breadboard are the _power rails_. Each power rail has two long electrically connected rows, and are often connected to batteries or some other power source."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "sparkfun guide",
              "url": "https://learn.sparkfun.com/tutorials/how-to-use-a-breadboard/all"
            }
          ]
        },
        {
          "type": "heading",
          "value": "Tips for breadboard usage"
        },
        {
          "type": "text",
          "value": "1. To make breadboard connections, DuPont style jumper wires or single core 22AWG wire is most convenient. Avoid multistranded wire."
        },
        {
          "type": "text",
          "value": "2. Keep wires and wire leads as short as possible, to avoid clutter and make troubleshooting easier."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/neatbb.jpg",
          "alt": "Image",
          "caption": ""
        }
      ]
    },
    {
      "id": "lidar",
      "title": "LIDAR",
      "category": "electronics",
      "excerpt": "LIDAR sensors for distance measurement and mapping.",
      "subcategory": "Sensors",
      "content": [
        {
          "type": "heading",
          "value": "Lidar"
        },
        {
          "type": "text",
          "value": "Lidar is a method for calculating distances between objects with the help of a laser and measuring the amount of time taken for the reflected light to return back."
        },
        {
          "type": "heading",
          "value": "Lidar Sensor"
        },
        {
          "type": "text",
          "value": "A Lidar sensor emits pulsed light waves into the surrounding environment. These pulses bounce off of    obstacles and the surrounding environment and then return to the sensor. The sensor then, keeps a track of time it took for the light to bounce off and thus calculating the distance between obstacles. Repeating this process constantly creates a real-time map of the environment."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/lidar-lidar.jpg",
          "alt": "image",
          "caption": "image"
        },
        {
          "type": "text",
          "value": "As an example of how a lidar sensor calculates the distance between the sensor and an obstacle,"
        },
        {
          "type": "text",
          "value": "Let's define the following variables,\n1) Speed of light, $c = 3 √ó 10^8 m/s$\n2) time taken for light to travel from the lidar sensor, hitting the obstacle and returning back to the sensor, $t$\n3) Distance between the obstacle and the sensor, $d$"
        },
        {
          "type": "text",
          "value": "Say that the time taken, $t = 5 √ó 10^{-8} sec$ (Observe the order of magnitude $t$)"
        },
        {
          "type": "text",
          "value": "So, to calculate the distance $d$, we use the Newton's second law of motion"
        },
        {
          "type": "text",
          "value": "$$ S = u \\cdot t + \\frac{1}{2} \\cdot a \\cdot t^2 $$"
        },
        {
          "type": "text",
          "value": "Since, speed of light constant, replacing, $a = 0$, $u = c$, and, $S = d$  we get,"
        },
        {
          "type": "text",
          "value": "$$ d = c \\cdot t $$"
        },
        {
          "type": "text",
          "value": "$$ d = 3 √ó 10^8 √ó 5 * 10^{-8} $$"
        },
        {
          "type": "text",
          "value": "$$ d = 15m $$"
        },
        {
          "type": "text",
          "value": "Therfore, the distance between the sensor and the obstacle is calculated to be 15 meters. This is the basic calculation that goes into calculating the distances."
        },
        {
          "type": "subheading",
          "value": "Types of Lidar Systems"
        },
        {
          "type": "text",
          "value": "1) Airborne Lidar - This is installed on aerial drones or vehicles like helicopters. It emits light towards the ground surface giving a fairly detailed and quick map of the terrain above which the vehicle or drone is flying. It is also used for topographic survey."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/lidar-airborne_lidar.jpg",
          "alt": "image",
          "caption": "image"
        },
        {
          "type": "text",
          "value": "2) Terrestrial Lidar - This is generally installed on vehicles moving on the earth's surface. These give a detailed map, and can be used to make a robot or a vehicle navigate through it's evironment. It is also used for observing highways, roads and infrastructure."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/lidar-terrestrial_lidar.png",
          "alt": "image",
          "caption": "image"
        },
        {
          "type": "subheading",
          "value": "Components of a basic Lidar Sensor"
        },
        {
          "type": "image",
          "src": "/images/handbook/images/lidar-components_of_lidar.png",
          "alt": "image",
          "caption": "image"
        },
        {
          "type": "text",
          "value": "A lidar sensor generally consists of 4 main components: \n1) Light source - Generally a laser (or anything that emits light in pulses)\n2) Optical components - There are multiple optical components for example, the light through the sensor, falls on a rotating/oscillating mirror so as to change the direction of light to cover a 360 view. An optical lens helps to focus light on the photodetector.\n3) photodector - The light is recieved by this photodetector and the signal is processed electronically like frequency of light (for speed measurements) and the time taken for the light to bounce.\n4) GPS - These sensors need a GPS system to determine the exact position and orientation of the sensor in 3D space."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "here.",
              "url": "https://www.newport.com/n/lidar"
            }
          ]
        },
        {
          "type": "heading",
          "value": "Lidar usage"
        },
        {
          "type": "text",
          "value": "To implement Lidar into your ros program, these are the following steps you must follow:"
        },
        {
          "type": "text",
          "value": "* Connect your Lidar sensor to a power supply, and connect a data transmitter to the Lidar sensor and the computer.\n* You need to give permissions to the on data input port of the computer. To check the permissions, type\n```bash\nls -l /dev/tty\n```\n* If your permissions are set properly, you should get an output like shown below. Just focus on the starting part, ```crw-rw-rw```. If instead, it is something of the form ```crw-rw--```, then your permissions are not set properly.\n```bash\ncrw-rw-rw- 1 root dialout 5, 0 Sep  6 23:50 /dev/ttyACM0\n```\n* To set permissions, (replace ```ACM0``` with whatever your ports are)\n```bash\nsudo chmod a+rw /dev/ttyACM0\n```\n* Next, you need to download the package of your Lidar manufacturer. Following are the common packages and their github links. You need to clone these github repositories in the src directory of your catkin workspace."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "Slamtec",
              "url": "https://github.com/Slamtec/rplidar_ros"
            },
            {
              "name": "YDLiDAR",
              "url": "https://github.com/EAIBOT/ydlidar"
            },
            {
              "name": "Hokuyo",
              "url": "https://github.com/ros-drivers/urg_node"
            },
            {
              "name": "ROS SICK",
              "url": "https://github.com/SICKAG/sick_scan"
            },
            {
              "name": "ROS2 SICK",
              "url": "https://github.com/SICKAG/sick_scan2"
            },
            {
              "name": "RoboSense",
              "url": "https://github.com/RoboSense-LiDAR/rslidar_sdk"
            }
          ]
        },
        {
          "type": "text",
          "value": "* After you have cloned the ros packages, go into your workspace directory,\n```bash\ncatkin_make\nsource devel/setup.bash\n```\n* Now just run the launch file according to your Lidar manufacturer package. For the above 6 manufacturers, run the following launch files. (If you are getting package not found error, please give appropriate permissions to the launch files using chmod)."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "github repo",
              "url": "https://github.com/SICKAG/sick_scan"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "github repo",
              "url": "https://github.com/SICKAG/sick_scan2"
            }
          ]
        },
        {
          "type": "text",
          "value": "6) RoboSense\n        ```bash\n        roslaunch rslidar_sdk start.launch\n        ```"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this link.",
              "url": "https://www.generationrobots.com/blog/en/lidar-integration-with-ros-quickstart-guide-and-projects-ideas"
            }
          ]
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this link",
              "url": "https://maker.pro/ros/tutorial/how-to-use-a-lidar-sensor-with-robot-operating-system-ros"
            }
          ]
        },
        {
          "type": "heading",
          "value": "Applications of Lidar"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "this research paper",
              "url": "https://www.isprs.org/proceedings/XXXVII/congress/3b_pdf/50.pdf"
            }
          ]
        },
        {
          "type": "heading",
          "value": "Companies working on Lidar technologies"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "tuSimple",
              "url": "https://www.tusimple.com/"
            },
            {
              "name": "AEye",
              "url": "https://www.aeye.ai/"
            },
            {
              "name": "SiLC Technologies",
              "url": "https://www.silc.com/"
            }
          ]
        },
        {
          "type": "heading",
          "value": "References -"
        },
        {
          "type": "text",
          "value": "* George, N., 2021. 11 Interesting LiDAR Applications. [online] Blog.cloudfactory.com. Available at: <https://blog.cloudfactory.com/interesting-lidar-applications> [Accessed 7 September 2021]."
        },
        {
          "type": "text",
          "value": "* Geospatial World. 2021. What is LiDAR technology and how does it work?. [online] Available at: <https://www.geospatialworld.net/blogs/what-is-lidar-technology-and-how-does-it-work/> [Accessed 7 September 2021]."
        },
        {
          "type": "text",
          "value": "* Microdrones.com. 2021. 5 Compelling Applications for LiDAR Technology. [online] Available at: <https://www.microdrones.com/en/content/5-compelling-applications-for-lidar-technology/> [Accessed 7 September 2021]."
        },
        {
          "type": "text",
          "value": "* Sentech. 2021. The revealing science behind Lidar technology. [online] Available at: <https://www.sentech.nl/en/sensor-technology/revealing-science-behind-lidar-technology/> [Accessed 7 September 2021]."
        },
        {
          "type": "text",
          "value": "* Velodyne Lidar. 2021. What is Lidar? Learn How Lidar Works | Velodyne Lidar. [online] Available at: <https://velodynelidar.com/what-is-lidar/> [Accessed 7 September 2021]."
        }
      ]
    },
    {
      "id": "servo-motor",
      "title": "Servo Motors",
      "category": "electronics",
      "excerpt": "Understanding servo motors and their applications in robotics.",
      "subcategory": "Motors",
      "content": [
        {
          "type": "heading",
          "value": "Servo Motors"
        },
        {
          "type": "text",
          "value": "Servo motors are simply just electric motors which give the users precise control over the angle of rotation, speed and torque of the motor. The shaft of a servo motor can be made to rotate by a certain angle and then it waits till the next signal is given to it. Moreover, the speed and torque, and in certain applications, even the sense of rotation of the motor can be adjusted by changing the command signal given to the motor. Whereas on the other hand, this is not possible in a simple electric motor, as it runs at a constant speed in the same direction as long as it is connected to a constant power supply. Apart from increased control, servo motors also provide high precision owing to its working principle - the servomechanism."
        },
        {
          "type": "heading",
          "value": "What is Servomechanism ?"
        },
        {
          "type": "text",
          "value": "Servomechanism is a closed loop control system which aims at achieving a fixed value of the output based on the given command, without using a variable input signal. It works by calculating the difference between the reference input signal or the command signal and the output signal received from a sensor. The feedback signal thus obtained, acts as the input signal for the device to be controlled. Hence, with the help of this feedback mechanism, we can make the output equal the reference input without having to alter the reference input manually at regular intervals. Once the output signal becomes equal to the command signal, the feedback signal goes to zero and hence the process stops till a new command signal is given."
        },
        {
          "type": "heading",
          "value": "Working of a Servo motor"
        },
        {
          "type": "text",
          "value": "A servo motor construction consists of a simple electric motor, some gears, a potentiometer/encoder/resolver, an error detector amplifier, and a control circuit. \nPotentiometers, encoders and resolvers all perform the same function by acting as sensors that measure the rotary position of the motor shaft. There are however certain differences in the way they function. If interested, you can take a look at these resources which give a detailed comparison between"
        },
        {
          "type": "text",
          "value": "- [Potentiometer](https://www.arrow.com/en/research-and-events/articles/encoder-vs-potentiometer-how-to-choose) [and](https://www.arrow.com/en/research-and-events/articles/encoder-vs-potentiometer-how-to-choose) [Encoder](https://www.arrow.com/en/research-and-events/articles/encoder-vs-potentiometer-how-to-choose)\n- [Encoder](https://www.motioncontroltips.com/faq-why-are-so-many-designers-replacing-resolvers-with-encoders/) [and](https://www.motioncontroltips.com/faq-why-are-so-many-designers-replacing-resolvers-with-encoders/) [Resolver](https://www.motioncontroltips.com/faq-why-are-so-many-designers-replacing-resolvers-with-encoders/)"
        },
        {
          "type": "text",
          "value": "Let us consider the simple case of a potentiometer used in the servo motor to clearly understand its working. \nThe potentiometer gives the output reference signal by sensing the position of the shaft, hence its knob is positioned such that it does not produce any signal in the initial condition. Now, the command signal, i.e. the input reference signal,  is introduced. This command signal represents how much we want the motor shaft to rotate. Next, the input reference signal and the output reference signal are fed into the error detector amplifier, where their difference is amplified and then generated as the output. This output from the amplifier acts as the input signal for the servo motor, which now starts rotating. The knob of the potentiometer is linked to the motor shaft with the help of a gear arrangement. Thus, as the shaft rotates, the knob of the potentiometer also rotates in a way such that the difference between the input and output reference signals decreases until it becomes zero. When the difference becomes zero, the output of the amplifier also goes to zero and no input signal will be given to the motor, due to which it stops rotating. Now it will remain in this condition until a new command signal is given, so that it generates a difference with the output from the potentiometer, and the process is repeated again."
        },
        {
          "type": "heading",
          "value": "Applications of Servo motors"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "1",
              "url": "https://realpars.com/servo-motor/"
            },
            {
              "name": "2",
              "url": "https://www.efxkits.us/different-types-servo-motor-applications/"
            }
          ]
        }
      ]
    },
    {
      "id": "wifi-module",
      "title": "WiFi Module",
      "category": "electronics",
      "excerpt": "WiFi modules for wireless communication in robotics projects.",
      "subcategory": "Modules",
      "content": [
        {
          "type": "heading",
          "value": "Wi-Fi module"
        },
        {
          "type": "text",
          "value": "Wifi modules or wifi microcontrollers are used to send and recieve data over Wi-Fi. They can also accept commands over the Wi-Fi. Wi-Fi modules are used for communications bewtween devices. They are most commonly used in the field of Internet of Thnigs."
        },
        {
          "type": "heading",
          "value": "ESP8266"
        },
        {
          "type": "text",
          "value": "ESP8266 is the most widely used Wi-Fi module. It is a low-cost microchip with a full TCP/IP stack and microcontroller capability, produced by Espressif Systems. This small module allows microcontrollers to connect to a Wi-Fi network and make simple TCP/IP connections."
        },
        {
          "type": "text",
          "value": "ESP8226 comes with the capabilites of:-<br>"
        },
        {
          "type": "text",
          "value": "1. 2.4 Ghz Wi-Fi<br>\n2. General-purpose input/output (16 GPIO)<br>\n3. Inter-Integrated Circuit (I¬≤C) serial communication protocol<br>\n4. Analog-to-digital conversion (10-bit ADC)<br>"
        },
        {
          "type": "text",
          "value": "It runs at operating voltage of 3V and can handle maximum voltage of around 3.6V. It can be easily interfaced with microcontrollers board via Serial Port. There are numerous breakout boards available based on ESP8266 Wifi Module like ESP8266 NodeMCU V3. Because of its compact size, its most importantly used in autonomous project."
        },
        {
          "type": "subheading",
          "value": "ESP8266 pinout"
        },
        {
          "type": "image",
          "src": "/images/handbook/images/pinout.png",
          "alt": "ESP8266 pinout",
          "caption": "ESP8266 pinout"
        },
        {
          "type": "text",
          "value": "|Pin Number|Pin Name|Working|\n|-|-|-|\n|1|RX |Serial Receiver Pin| \n|2|VCC|Power Pin (+3.3 V; can handle up to 3.6 V|\n|3|GPIO 0|General-Purpose I/O No. 0|\n|4|RST|Reset|\n|5|CH_PD|Chip power-down|\n|6|GPIO 2|General-purpose I/O No. 2|\n|7|TX|Serial Transmitter Pin|\n|8|GND|Ground|"
        },
        {
          "type": "subheading",
          "value": "Scanning and dispalying available WiFi networks using ESP8266"
        },
        {
          "type": "text",
          "value": "ESP8266 comes with a built in micro-controller. It has a Arduino support and can be programmed easily."
        },
        {
          "type": "text",
          "value": "#### Arduino support for ESP8266"
        },
        {
          "type": "text",
          "value": "1. Download Arduino IDE from Arduino.cc(1.6.4 or greater)\n> <https://www.arduino.cc/en/Main/Software>"
        },
        {
          "type": "text",
          "value": "2. Install the ESP8266 Board Package\n    - Select **Preferences** under **File**\n    <center>![Preferences](images/preferences.png)</center>\n    - Enter <http://arduino.esp8266.com/stable/package_esp8266com_index.json> into Additional Boards Manager URL's field under preferences.\n    <center>![Additional Boards Manager URL](images/url.png)</center>\n    - Select the **Board Manager** under the Tools.\n    <center>![Board Manager](images/board_manager.png)</center>\n    - Use the **Board Manager** to install the ESP8266 package.\n    <center>![Install ESP8266 package](images/install.png)</center>\n    - Restart the Arduino IDE and Select the **Generic ESP8266 Module** board\n    <center>![Select specific board](images/board.png)</center>"
        },
        {
          "type": "text",
          "value": "#### Connection"
        },
        {
          "type": "image",
          "src": "/images/handbook/images/connection.png",
          "alt": "Circuit diagram",
          "caption": "Circuit diagram"
        },
        {
          "type": "text",
          "value": "A USB to serial converter is nedded to program ESP8266. The above image shows connections made from Explore USB to Serial and Explore Wifi boards."
        },
        {
          "type": "text",
          "value": "#### Code"
        },
        {
          "type": "code",
          "language": "cpp",
          "value": "#include \"ESP8266WiFi.h\"\n \nvoid setup() {\n  Serial.begin(115200);\n \n  // Set WiFi to station mode and disconnect from an AP if it was previously connected\n  WiFi.mode(WIFI_STA);\n  WiFi.disconnect();\n  delay(100);\n \n  Serial.println(\"Setup done\");\n}\n \nvoid loop() {\n  Serial.println(\"scan start\");\n \n  // WiFi.scanNetworks will return the number of networks found\n  int n = WiFi.scanNetworks();\n  Serial.println(\"scan done\");\n  if (n == 0)\n    Serial.println(\"no networks found\");\n  else\n  {\n    Serial.print(n);\n    Serial.println(\" networks found\");\n    for (int i = 0; i < n; ++i)\n    {\n      // Print SSID and RSSI for each network found\n      Serial.print(i + 1);\n      Serial.print(\": \");\n      Serial.print(WiFi.SSID(i));\n      Serial.print(\" (\");\n      Serial.print(WiFi.RSSI(i));\n      Serial.print(\")\");\n      Serial.println((WiFi.encryptionType(i) == ENC_TYPE_NONE)?\" \":\"*\");\n      delay(10);\n    }\n  }\n  Serial.println(\"\");\n \n  // Wait a bit before scanning again\n  delay(5000);\n}"
        },
        {
          "type": "subheading",
          "value": "References"
        },
        {
          "type": "text",
          "value": "1. [Documentation](https://arduino-esp8266.readthedocs.io/en/latest/libraries.html#wifi-esp8266wifi-library) of ESP8266.h library.\n2. [Technical Reference Manual](https://www.espressif.com/sites/default/files/documentation/esp8266-technical_reference_en.pdf) by Espressif Systems.\n3. [ESP8266 Community Forum](https://www.esp8266.com/)\n4. [ESP8266 for IoT guide](https://www.nabto.com/esp8266-for-iot-complete-guide/) by Nabto."
        }
      ]
    },
    {
      "id": "mechanical-intro",
      "title": "Introduction to Mechanical Design",
      "category": "mechanical",
      "excerpt": "Overview of mechanical aspects in robotics - design, kinematics, dynamics, and CAD.",
      "content": [
        {
          "type": "heading",
          "value": "Introduction"
        },
        {
          "type": "text",
          "value": "Mechanical aspects of robotics involve desiging,building and testing mechanical sensors and devices for a robot."
        },
        {
          "type": "text",
          "value": "This includes the robot configuration, type of robot, joint mechanisms, axes, heat transfer characteristics, mounting positions, among many other aspects that go into the creation of a new robot. \nCAD or other design software is used to create a new robot concept and how to best manufacture it."
        },
        {
          "type": "text",
          "value": "Mechanical design also involves solving the kinematics and dynamics equation of the robot, which are essential for peforming any task with robots."
        }
      ]
    },
    {
      "id": "mechanical-101",
      "title": "Mechanical 101",
      "category": "mechanical",
      "excerpt": "Basic mechanical concepts for robotics.",
      "subcategory": "Basics",
      "content": [
        {
          "type": "heading",
          "value": "Mechanical 101"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "Aasim Sayyed",
              "url": "https://www.linkedin.com/in/aasim-sayyed-a966b423a/?originalSubdomain=in"
            },
            {
              "name": "here",
              "url": "https://drive.google.com/file/d/1TSnQcirmtd4-c1_goBCdhXNydBE2Uf8y/view?usp=drive_link"
            }
          ]
        }
      ]
    },
    {
      "id": "gears",
      "title": "Gears",
      "category": "mechanical",
      "excerpt": "Comprehensive guide to gears - types, advantages, and applications in robotics.",
      "subcategory": "Components",
      "content": [
        {
          "type": "heading",
          "value": "Gears"
        },
        {
          "type": "heading",
          "value": "What are Gears?"
        },
        {
          "type": "text",
          "value": "*   Gears are defined as toothed element which are used for transmitting rotary motion from one shaft to another.\n*   Gears are most often used in transmissions to convert an electric motor‚Äôs high speed and low torque to a shaft‚Äôs requirements for low speed high torque.\n*   Gears essentially allow positive engagement between Teeth, so high forces can be transmitted while still undergoing essentially rolling contact.\n*   Gears do not depend on friction as belt drives and do best when friction is minimized.\n*   The motion and power transmitted by gears is kinematically equivalent to that transmitted by friction wheels or discs."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/gears1.png",
          "alt": "gears1",
          "caption": "gears1"
        },
        {
          "type": "text",
          "value": "_(Transmission of Power)_</center>"
        },
        {
          "type": "text",
          "value": "*   In order to avoid the slipping, a number of projections (called teeth) as shown in Fig. (b), are provided on the periphery of the wheel A, which will fit into the corresponding recesses on the¬† periphery of the wheel B. A friction wheel with the teeth cut on it is known as **_toothed wheel or gear._** **_The usual connection to show the toothed wheels is by their pitch circles_**"
        },
        {
          "type": "image",
          "src": "/images/handbook/images/gears2.png",
          "alt": "gears2",
          "caption": "gears2"
        },
        {
          "type": "heading",
          "value": "Advantages and Disadvantages"
        },
        {
          "type": "subheading",
          "value": "Advantages"
        },
        {
          "type": "text",
          "value": "1.  It transmits exact velocity ratio.\n2.  It may be used to transmit large power.\n3.  It has high efficiency.\n4.  It has reliable service.\n5.  It has compact layout."
        },
        {
          "type": "subheading",
          "value": "Disadvantages"
        },
        {
          "type": "text",
          "value": "1.  The manufacture of gears require special tools and equipment.\n2.  The error in cutting teeth may cause vibrations and noise during operation."
        },
        {
          "type": "heading",
          "value": "Types of Gears"
        },
        {
          "type": "text",
          "value": "*   **According to the position of axes of the shaft**\n    *   Parallel: Spur gear, Helical gear, Rack and Pinion\n    *   Intersecting: Bevel Gear\n    *   Non Intersecting and Non Parallel: Worm and Worm Gears"
        },
        {
          "type": "text",
          "value": "*   **According to the periphery velocity**\n    *   Low Velocity\n    *   Medium Velocity\n    *   High Velocity"
        },
        {
          "type": "text",
          "value": "*   **According to the type of gearing**\n    *   External Gearing\n    *   Internal Gearing\n    *   Rack and Pinion"
        },
        {
          "type": "text",
          "value": "*   **According to the position of teeth on surface**\n    *   Straight\n    *   Inclined\n    *   Curved"
        },
        {
          "type": "heading",
          "value": "Spur Gear"
        },
        {
          "type": "text",
          "value": "Spur gears are a type of cylindrical gear, with shafts that are parallel and coplanar, and teeth that are straight and oriented parallel to the shafts. They‚Äôre arguably the simplest and most common type of gear ‚Äì easy to manufacture and suitable for a wide range of applications."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/gears3.png",
          "alt": "gears3",
          "caption": "gears3"
        },
        {
          "type": "text",
          "value": "The teeth of a spur gear have an involute profile and mesh one tooth at a time. The involute form means that spur gears only produce radial forces (no axial forces), but the method of tooth meshing causes high stress on the gear teeth and high noise production. Because of this, spur gears are typically used for lower speed applications, although they can be used at almost any speed."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/gears4.png",
          "alt": "gears4",
          "caption": "gears4"
        },
        {
          "type": "text",
          "value": "Spur gears are generally seen as best for applications that require speed reduction and torque multiplication, such as ball mills and crushing equipment. Examples of high-speed applications that use spur gears ‚Äì despite their high noise levels ‚Äì include consumer appliances such as washing machines and blenders. And while noise limits the use of spur gears in passenger automobiles, they are often used in aircraft engines, trains, and even bicycles."
        },
        {
          "type": "heading",
          "value": "Helical Gear"
        },
        {
          "type": "text",
          "value": "The teeth of a helical gear are set at an angle (relative to axis of the gear) and take the shape of a helix. This allows the teeth to mesh gradually, starting as point contact and developing into line contact as engagement progresses."
        },
        {
          "type": "text",
          "value": "One of the most noticeable benefits of helical gears over spur gears is less noise, especially at medium- to high-speeds. Also, with helical gears, multiple teeth are always in mesh, which means less load on each individual tooth. This results in a smoother transition of forces from one tooth to the next, so that vibrations, shock loads, and wear are reduced. One interesting thing about helical gears is that if the angles of the gear teeth are correct, they can be mounted on perpendicular shafts, adjusting the rotation angle by 90 degrees."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/gears5.png",
          "alt": "gears5",
          "caption": "gears5"
        },
        {
          "type": "text",
          "value": "Helical gears are often the default choice in applications that are suitable for spur gears but have non-parallel shafts. They are also used in applications that require high speeds or high loading. And regardless of the load or speed, they generally provide smoother, quieter operation than spur gears."
        },
        {
          "type": "heading",
          "value": "Bevel Gear"
        },
        {
          "type": "text",
          "value": "Bevel gears¬†are¬†gears¬†where the axes of the two¬†shafts¬†intersect and the¬†tooth-bearing faces of the gears themselves are conically shaped. Bevel gears are most often mounted on shafts that are 90 degrees apart, but can be designed to work at other angles as well. The pitch surface of bevel gears is a¬†cone."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/gears6.png",
          "alt": "gears6",
          "caption": "gears6"
        },
        {
          "type": "text",
          "value": "There are several¬†types of bevel gears¬†based on the shape of their teeth."
        },
        {
          "type": "text",
          "value": "*   **Straight**\n    *   They have conical pitch surface and teeth are straight and tapering towards apex.\n    *   They are useful to verify the transmission of the motion that is generated between axes that intersect within one same plane, almost always at a¬†90-degree¬†angle.\n    *   Straight bevel gears have many uses in¬†watches, dentist drills, hand drills and vending machines."
        },
        {
          "type": "text",
          "value": "*   **Spiral**\n    *   They have curved teeth at an angle allowing tooth contact to be gradual and smooth and operate at very steep planes.\n    *   Spiral bevel gears provide a¬†high level of control over the way in which teeth mesh, and their design allows for certain mounting deflections without excessively increasing the load on either end of the teeth.\n    *   They can be used at high speeds, and are usually employed in¬†motorcycle and bicycle gears."
        },
        {
          "type": "text",
          "value": "*   **Hypoid**\n    *   These are similar to spiral bevel, but the pitch surfaces are¬†hyberbolic¬†and not conical. The pinion can be offset above or below the gear center, thus allowing larger pinion diameter, longer life, and smoother mesh.\n    *   In addition to being used in industrial machinery, they are commonly used in the automotive industry, where it is used in¬†rear-wheel drive vehicles¬†to connect the driveshaft with the wheels."
        },
        {
          "type": "heading",
          "value": "Worm Gears"
        },
        {
          "type": "text",
          "value": "Worm gears are constructed of a worm and a gear (sometimes referred to as a worm wheel), with non-parallel, non-intersecting shafts oriented 90 degrees to each other. The worm is analogous to a screw with a V-type thread, and the gear is analogous to a spur gear. The worm is typically the driving component, with the worm‚Äôs thread advancing the teeth of the gear."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/gears7.png",
          "alt": "gears7",
          "caption": "gears7"
        },
        {
          "type": "text",
          "value": "The primary benefit of worm gears is their ability to provide high reduction ratios (like 20:1 and even up to 300:1 or greater) and correspondingly high torque multiplication. They can also be used as speed reducers in low- to medium-speed applications. And, because their reduction ratio is based on the number of gear teeth alone, they are more compact than other types of gears. Worm gears are used widely in material handling and transportation machinery, machine tools, automobiles etc."
        },
        {
          "type": "heading",
          "value": "Herringbone Gear"
        },
        {
          "type": "text",
          "value": "The herringbone gear consists of two sets of gear teeth on the same gear, one right hand and one left hand. Having both hands of gear teeth, causes the thrust of one set to cancel out the thrust of the other. It is used for transmitting power between parallel shafts. It was developed to overcome the disadvantage of the high-end thrust that is present with single-helical gears. Also another advantage of this gear type is quiet, smooth operation at higher speeds. They are mostly used on heavy machinery."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/gears8.png",
          "alt": "gears8",
          "caption": "gears8"
        },
        {
          "type": "heading",
          "value": "Rack and Pinion"
        },
        {
          "type": "text",
          "value": "A rack and pinion drive system consists of a rack (or a ‚Äúlinear gear‚Äù) and a pinion (or ‚Äúcircular gear‚Äù), which operate to convert rotational motion into linear motion. A rack and pinion drive can use both straight and helical gears. These systems provide high-speed travel over extremely long lengths and are frequently used in large gantry systems for material handling, machining, welding and assembly, especially in the automotive, machine tool, and packaging industries."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/gears9.png",
          "alt": "gears9",
          "caption": "gears9"
        }
      ]
    },
    {
      "id": "drive-mechanism",
      "title": "Drive Mechanism",
      "category": "mechanical",
      "excerpt": "Understanding different drive mechanisms for wheeled robots - differential drive, Ackermann steering, and omnidirectional drive.",
      "subcategory": "Kinematics",
      "content": [
        {
          "type": "heading",
          "value": "Drive Mechanism"
        },
        {
          "type": "text",
          "value": "Wheeled mobile robots may be classified in two major categories, omnidirectional and nonholonomic."
        },
        {
          "type": "text",
          "value": "**Omnidirectional wheeled mobile robots** typically employ either omniwheels or mecanum wheels. An omniwheel is a typical wheel augmented with rollers on its outer circumference. These rollers spin freely about axes in the plane of the wheel and tangential to the wheel's outer circumference, and they allow sideways sliding while the wheel drives forward or backward without slip in that direction. Mecanum wheels are similar except that the spin axes of the circumferential rollers are not in the plane of the wheel. The sideways sliding allowed by omniwheels and mecanum wheels ensures that there are no velocity constraints on the robot's chassis."
        },
        {
          "type": "text",
          "value": "**Nonholomic wheeled robots** are subject to a single Pfaffian velocity constraint i.e. they cannot move sideways or parallel to the axis of the axel. Example for a nonholomic wheeled robot is a car and despite this velocity constraint, a car can reach any $(\\phi,x,y)$ configuration in an obstacle-free plane. In other words, the velocity constraint cannot be integrated to an equivalent configuration constraint, and therefore it is a nonholonomic constraint."
        },
        {
          "type": "text",
          "value": "If we want to prescribe the robot‚Äôs movements in the environment, we need to know how the robot variables relate to the primary variables we can control: the angular positions and velocities of the wheel shafts. Therefore, a kinematical model of the robot has to be developed."
        },
        {
          "type": "heading",
          "value": "Modeling of an Omnibase Robot"
        },
        {
          "type": "text",
          "value": "Generally Omni wheeled robots use either a three wheeled platform or a four wheeled platform. Each design has its own advantages and disadvantages. In a three wheel design, wheels are at $120^{\\circ}$ from each other and they offers greater traction as any reactive force is distributed through only three points and the robot is well balanced even on uneven terrain."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/drive0.png",
          "alt": "drive0",
          "caption": "drive0"
        },
        {
          "type": "text",
          "value": "The configuration of a robot is defined in the form $q = (x,y,\\theta)$, $d$ is the distance between wheels and the center of the robot $v_i$ and $\\omega_i$ are the linear and angular velocity of the $i^{th}$ wheel respectively. $v, v_n$ are the two components of the linear velocity of the robot and $\\omega$ is the angular velocity. The well known kinematic model of an omnidirectional robot located a $(x,y,\\theta)$ can be written as $v_x(t) = dx(t)/dt , v_y(t) = dy(t)/dt$ and $\\omega(t) = d\\theta(t)/dt$. For a three wheeled robot"
        },
        {
          "type": "text",
          "value": "$$ \\begin{bmatrix} v_0(t)\\\\ v_1(t)\\\\ v_2(t) \\end{bmatrix} = \\begin{bmatrix} -sin\\pi/3 & cos\\pi/3 & d\\\\ 0 & -1 & d\\\\ sin\\pi/3 & cos\\pi/3 & d \\end{bmatrix} \\begin{bmatrix} v(t)\\\\ v_n(t)\\\\ \\omega(t) \\end{bmatrix} $$"
        },
        {
          "type": "text",
          "value": "Applying the inverse kinematics is possible to obtain the equations that determine the robot speeds related the wheels speed. Solving in order of $v$, $v_n$ and $\\omega$, the following can be found"
        },
        {
          "type": "text",
          "value": "$$ v(t) = (\\sqrt{3}/3)(v_2(t) - v_0(t))\\]\n\\[v_n(t)=(1/3)(v_2(t) +v_0(t))‚àí(2/3)v_1(t)\\]\n\\[\\omega(t)=(1/(3d))(v_0(t) +v_1(t) +v_2(t)) $$"
        },
        {
          "type": "heading",
          "value": "Modeling of a Nonholomic Robot"
        },
        {
          "type": "text",
          "value": "A nonholomic robot is modelled in differnet ways which will then dictate the drive mechanism that can be applied on the robot. Differnet drive mechanism and modelling for a nonholomic robot are:"
        },
        {
          "type": "text",
          "value": "*  Unicycle model\n*  Differential Drive\n*  Ackermann Steering"
        },
        {
          "type": "subheading",
          "value": "Unicycle Model"
        },
        {
          "type": "text",
          "value": "The simplest wheeled mobile robot is a single upright rolling wheel, or unicycle. The configuration of a robot with a wheel of radius $r$ can be written in the form $q = (\\phi,x,y,\\theta)$, where $(x,y)$ is the contact point, $\\phi$ is the heading direction, and $\\theta$ is the rolling angle of the wheel. The kinematic equations can be written as"
        },
        {
          "type": "image",
          "src": "/images/handbook/images/drive1.png",
          "alt": "drive1",
          "caption": "drive1"
        },
        {
          "type": "text",
          "value": "$$ \\dot{q} = \\begin{bmatrix} \\dot{\\phi}\\\\ \\dot{x}\\\\ \\dot{y}\\\\ \\dot{\\theta} \\end{bmatrix} = \\begin{bmatrix} 0 & 1\\\\ rcos\\phi & 0\\\\ rsin\\phi & 0\\\\ 1 & 0 \\end{bmatrix}  \\begin{bmatrix} u_1\\\\ u_2 \\end{bmatrix} = G(q)u = g_1(q)u_1 + g_2(q)u_2 $$"
        },
        {
          "type": "text",
          "value": "The control inputs are $u = (u_1,u_2)$, with $u_1$ the wheel's forward-backward driving speed and $u_2$ the heading direction turning speed."
        },
        {
          "type": "text",
          "value": "Three things to notice about these models are: (1) there is no drift - zero controls mean zero velocity; (2) the vector fields $g_i(q)$ are generally functions of the configuration $q$; and (3) $\\dot{q}$ is linear in the controls."
        },
        {
          "type": "subheading",
          "value": "Differnetial Drive"
        },
        {
          "type": "text",
          "value": "A differential drive is the most basic drive, which consists of two sets of wheels that can be driven independently. This is the most commonly used form of locomotion system used in robots as it‚Äôs the simplest and easiest to implement."
        },
        {
          "type": "text",
          "value": "A differential drive robot consists of two independently driven wheels of radius $r$ that rotate about the same axis, as well as one or more caster wheels, ball casters, or low-friction sliders that keep the robot horizontal. If both the wheels are driven in the same direction and speed, the robot will go in a straight line."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/drive2.jpg",
          "alt": "drive2",
          "caption": "drive2"
        },
        {
          "type": "text",
          "value": "If both wheels are turned with equal speed in opposite directions, as is clear from the diagram shown, the robot will rotate about the central point of the axis. Otherwise, depending on the speed of rotation and its direction, the center of rotation may fall anywhere on the line defined by the two contact points of the tires."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/drive3.png",
          "alt": "drive3",
          "caption": "drive3"
        },
        {
          "type": "text",
          "value": "Let the distance between the driven wheels be $2d$ and choose the $(x,y)$ reference point halfway between the wheels. Writing the configuration as $q = (\\phi,x,y,\\theta_L,\\theta_R)$, where $\\theta_L$ and $\\theta_R$ are the rolling angles of the left and right wheels, respectively, the kinematic equations are"
        },
        {
          "type": "text",
          "value": "$$ \\dot{q} = \\begin{bmatrix} \\dot{\\phi}\\\\ \\dot{x}\\\\ \\dot{y}\\\\ \\dot{\\theta_L}\\\\ \\dot{\\theta_R} \\end{bmatrix} = \\begin{bmatrix} -r/2d & r/2d\\\\ \\frac{r}{2}cos\\phi & \\frac{r}{2}cos\\phi\\\\ \\frac{r}{2}sin\\phi & \\frac{r}{2}sin\\phi\\\\ 1 & 0\\\\ 0 & 1 \\end{bmatrix} \\begin{bmatrix} u_L\\\\ u_R \\end{bmatrix} $$"
        },
        {
          "type": "text",
          "value": "where $u_L$ is the angular speed of the left wheel and $u_R$ that of the right. A positive angular speed of each wheel corresponds to forward motion at that wheel."
        },
        {
          "type": "text",
          "value": "While we can vary the velocity of each wheel, for the robot to perform rolling motion, the robot must rotate about a point that lies along their common left and right wheel axis. The point that the robot rotates about is known as the ICC - Instantaneous Center of Curvature."
        },
        {
          "type": "text",
          "value": "By varying the linear velocity of the wheels $V_R$ and $V_L$, we can vary the radius of curvature $R$ that the robot follows. Because the rate of rotation $\\omega$ about the ICC must be the same for both wheels, we can write the following equations"
        },
        {
          "type": "text",
          "value": "$$ \\omega(R + d) = V_R\\] \n\\[\\omega(R - d) = V_L $$"
        },
        {
          "type": "text",
          "value": "A differential drive robot cannot move in the direction along the axis - this is a singularity. Differential drive vehicles are very sensitive to slight changes in velocity in each of the wheels. Small errors in the relative velocities between the wheels can affect the robot trajectory."
        },
        {
          "type": "subheading",
          "value": "Ackermann Steering"
        },
        {
          "type": "text",
          "value": "Drawbacks of the differential drive are its reliance on a caster wheel, which performs poorly at high speeds, and difficulties in driving straight lines as this requires both motors to drive at the exact same speed. These drawbacks are mitigated by car-like mechanisms, which are driven by a single motor and can steer their front wheels. This mechanism is known as Ackermann steering."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/drive4.png",
          "alt": "drive4",
          "caption": "drive4"
        },
        {
          "type": "text",
          "value": "To define the configuration of the car, we ignore the rolling angles of the four wheels and write $q = (\\phi,x,y,\\psi)$, where $(x,y)$ is the location of the midpoint between the rear wheels, $\\phi$ is the car's heading direction, and $\\psi$ is the steering angle of the car, defined at a virtual wheel at the midpoint between the front wheels. The controls are the forward speed $v$ of the car at its reference point and the angular speed $\\omega$ of the steering angle. The car's kinematics are"
        },
        {
          "type": "text",
          "value": "$$ \\dot{q} = \\begin{bmatrix} \\dot{\\phi}\\\\ \\dot{x}\\\\ \\dot{y}\\\\ \\dot{\\psi} \\end{bmatrix} = \\begin{bmatrix} (tan\\psi)/l & 0\\\\ cos\\phi & 0\\\\ sin\\phi & 0\\\\ 0 & 1 \\end{bmatrix} \\begin{bmatrix} v\\\\ \\omega \\end{bmatrix} $$"
        },
        {
          "type": "text",
          "value": "Disadvantages Of Ackermann Steering : The turning mechanism must be accurately controlled. A slight inaccuracy may cause large odometry errors The system is Non ‚Äì Holonomic hence path planning is extremely difficult as well as inaccurate There are no direct directional actuators."
        },
        {
          "type": "heading",
          "value": "Other type of Drive Mechanism"
        },
        {
          "type": "text",
          "value": "There are many different ways in which a robot can be modelled and controlled, some other drive mechanism used in various systems are"
        },
        {
          "type": "text",
          "value": "* **Skid Steering -** The left and right wheels are driven independently. Steering is accomplished by actuating each side at a different rate or in a different direction, causing the wheels or tracks to slip, or skid, on the ground. The wheels typically have no separate steering mechanism and hold a fixed straight alignment on the body of the machine. By turning the left and right wheel pairs at different speeds, the machine turns by skidding, or dragging its fixed-orientation wheels across the ground."
        },
        {
          "type": "text",
          "value": "* **Synchronous Drive -** This system uses synchronous rotation of its wheels to achieve motion & turns. It is made up of a system of motors. One set of which drive the wheels and the other set turns the wheels in a synchronous fashion The two sets can be directly mechanically coupled as they always move in the same direction with same speed."
        },
        {
          "type": "text",
          "value": "* **Articulated Drive -** Similar to Ackerman Steering concept, Articulated method drives a robot by deforming the entire chassis or frame to turn instead of just the wheels. This is generally used for industrial robots where a four wheeled robot is split into two, the front part and the rear part which is connected by a vertical hinge. A motor changes the angle of front part of chassis which turns the robot in a required direction and other motor drives it."
        },
        {
          "type": "heading",
          "value": "References"
        },
        {
          "type": "text",
          "value": "1. A 4-wheel omni drive robot - **Omnibase** developed by ERC, applying the concepts of omnidrive can be found [here](https://github.com/ERC-BPGC/omnibase).\n2. For more details on these drive mechanisms refer Chapter 13 of the **Modern Robotics - Mechanics, Planning, And Control** by *Kevin M. Lynch and Frank C. Park*, a video playlist of the same can be found [here](https://www.youtube.com/playlist?list=PLggLP4f-rq00uzTEwsywVcTF2fJ2YqAXX).\n3. A video on Differential Drive mechanism from **Control of Mobile Robots** course by *Dr. Magnus Egerstedt* can be found [here](https://youtu.be/wqUwmnKskJU).\n4. More information on Designing of Ackermann Steering can be read from this [paper](https://www.researchgate.net/publication/265755401_Design_of_an_Ackermann_Type_Steering_Mechanism)."
        }
      ]
    },
    {
      "id": "position-orientation",
      "title": "Position and Orientation",
      "category": "mechanical",
      "excerpt": "Understanding position and orientation in robotics.",
      "subcategory": "Kinematics",
      "content": [
        {
          "type": "heading",
          "value": "POSITION AND ORIENATION REPRESENTATION"
        },
        {
          "type": "subheading",
          "value": "Position and translation"
        },
        {
          "type": "text",
          "value": "The minimum number of coordinates required to locate a body in Euclidean space is six. A coordinate frame i consists of an origin, denoted $O_{i}$ and a triad of mutually orthogonal basis vectors, denoted $(\\hat x_{i} \\hat y_{i } \\hat z_{i})$, that are all fixed within a particular body. The pose of a body will always be expressed relative to some other body, so it can be expressed as the pose of one coordinate frame relative to another. Similarly, rigid-body displacements can be expressed as displacements between two coordinate frames, one of which may be referred to as moving, while the other may be referred to as fixed."
        },
        {
          "type": "text",
          "value": "The position of the origin of coordinate frame i relative to coordinate frame j can be denoted by the 3 X 1 vector"
        },
        {
          "type": "text",
          "value": "$$ ^{j} \\textbf {p} _{i} =  \\begin{pmatrix} ^{j} p^{x} _{i} \\\\ ^{j} p^{y} _{i} \\\\ ^{j} p^{z} _{i}   \\end{pmatrix}$$"
        },
        {
          "type": "text",
          "value": "The components of this vector are the Cartesian coordinates of $O_{i}$ in the j frame, which are the projections of the vector  $^{j} \\textbf {p} _{i}$  onto the corresponding axes."
        },
        {
          "type": "subheading",
          "value": "Orientation and Rotation"
        },
        {
          "type": "text",
          "value": "A rotation is a displacement in which at least one point in the rigid body remains in its initial position and not all lines in the body remain parallel to their initial orientations. The orientation of coordinate frame i relative to coordinate frame j can be denoted by expressing the basis vectors .$( \\hat x_{i} \\hat y_{i} \\hat z_{i})$ in terms of the basis vectors ,$( \\hat x_{j} \\hat y_{j} \\hat z_{j})$.This yields, $( ^{j}\\hat x_{i} ^{j}\\hat y_{i} ^{j}\\hat z_{i})$  which when written together as a  3X3 matrix is known as the rotation matrix. The components of $^{j}R_{i}$ are the dot products of the basis vectors of the two coordinate frames."
        },
        {
          "type": "text",
          "value": "$^{j}R_{i}$ = $\\begin{pmatrix} \\hat x _{i}.\\hat x _{j} &  \\hat y _{i}.\\hat x _{j} &  \\hat z _{i}.\\hat x _{j} \\\\  \\hat x _{i}.\\hat y _{j} &  \\hat y _{i}.\\hat y _{j} &  \\hat z _{i}.\\hat y _{j}  \\\\  \\hat x _{i}.\\hat z _{j} &  \\hat y _{i}.\\hat z _{j} &  \\hat z _{i}.\\hat z _{j} \\end{pmatrix}$"
        },
        {
          "type": "text",
          "value": "Because the basis vectors are unit vectors and the dot product of any two unit vectors is the cosine of the angle\nbetween them, the components are commonly referred to as direction cosines. An elementary rotation of frame i about the $z_{j}$ axis through an angle $\\theta$ is"
        },
        {
          "type": "text",
          "value": "$R_{z}(\\theta) = \\begin{pmatrix} \\cos(\\theta) & -\\sin(\\theta) & 0\\\\ \\sin(\\theta) & \\cos(\\theta) & 0\\\\ 0 & 0 & 1\\end{pmatrix}$"
        },
        {
          "type": "text",
          "value": "while the same rotation about $\\hat y_{j}$ axis is"
        },
        {
          "type": "text",
          "value": "$R_{Y}(\\theta) = \\begin{pmatrix} \\cos(\\theta) & 0 & \\sin(\\theta)\\\\ 0 & 1 & 0\\\\ -\\sin(\\theta) & 0 & \\cos(\\theta)\\end{pmatrix}$"
        },
        {
          "type": "text",
          "value": "and about the  axis $\\hat x_{j}$ is"
        },
        {
          "type": "text",
          "value": "$R_{X}(\\theta) = \\begin{pmatrix} 1 & 0 & 0\\\\ 0 & \\cos(\\theta) & -\\sin(\\theta)\\\\ 0 & \\sin(\\theta) & \\cos(\\theta)\\end{pmatrix}$"
        },
        {
          "type": "text",
          "value": "Rotation matrices are combined through simple matrix multiplication such that the orientation of frame i relative to frame k can be expressed as"
        },
        {
          "type": "text",
          "value": "$^{k}R_{i} = ^{k}R_{j} ^{j}R_{i}$"
        },
        {
          "type": "subheading",
          "value": "Euler Angles"
        },
        {
          "type": "text",
          "value": "For a minimal representation, the orientation of coordinate frame i relative to coordinate frame j can be denoted as a vector of three angles $(\\alpha , \\beta , \\gamma)^{T}$. These angles are known as Euler angles when each represents a rotation about an axis of a moving coordinate frame. In this way, the location of the axis of each successive rotation depends upon the preceding rotation(s), so\nthe order of the rotations must accompany the three angles to define the orientation."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "Fixed-Angles",
              "url": "https://www.youtube.com/watch?v=uG0P9RX65Ek"
            },
            {
              "name": "Quaternions",
              "url": "https://robotacademy.net.au/lesson/quaternions-representation-of-rotation-in-3d/"
            },
            {
              "name": "Angle-Axis",
              "url": "https://www.youtube.com/watch?v=-TUTqVOGSa8"
            }
          ]
        },
        {
          "type": "subheading",
          "value": "Homogeneous Transformations"
        },
        {
          "type": "text",
          "value": "With homogeneous transformations, position vectors and rotation matrices are combined together in a compact notation.\nAny vector $^{i}r$ expressed relative to the i coordinate frame can be expressed relative to the j coordinate frame if the position and orientation of the i frame are known relative to the j frame."
        },
        {
          "type": "text",
          "value": "$^{j}r = ^{j}R_{i} ^{i}r +  ^{j}p_{i}$"
        },
        {
          "type": "text",
          "value": "where $^{j}p_{i}$ is the position of the origin of coordinate frame i relative to coordinate frame j and  $^{j}R_{i}$ is the orientation of frame i relative to frame j ."
        },
        {
          "type": "text",
          "value": "The above equation can be written as"
        },
        {
          "type": "text",
          "value": "$\\begin{pmatrix} ^{j}r \\\\ 1 \\end{pmatrix}$ = $\\begin{pmatrix}  ^{j}R_{i}  &  ^{j}p_{i}\\\\ 0^{T} & 1 \\end{pmatrix}\\begin{pmatrix} ^{i}r \\\\ 1 \\end{pmatrix}$"
        },
        {
          "type": "text",
          "value": "where"
        },
        {
          "type": "text",
          "value": "$^{j}T_{i} = \\begin{pmatrix}  ^{j}R_{i}  &  ^{j}p_{i}\\\\ 0^{T} & 1 \\end{pmatrix}$"
        },
        {
          "type": "text",
          "value": "is the 4X4 homogeneous transformation matrix . Just like Rotation matrices, homogeneous transformation matrices can also be transformed using matrix cross-multiplication."
        },
        {
          "type": "text",
          "value": "$^{k}T_{i} = ^{k}T_{j} ^{j}T_{i}$"
        }
      ]
    },
    {
      "id": "joint-kinematics",
      "title": "Joint Kinematics",
      "category": "mechanical",
      "excerpt": "Understanding joint kinematics for robotic arms and manipulators.",
      "subcategory": "Kinematics",
      "content": [
        {
          "type": "heading",
          "value": "Joint Kinematics"
        },
        {
          "type": "text",
          "value": "The links that compose the robotic mechanism are assumed to be perfectly rigid bodies having surfaces that are geometrically perfect in both position and shape. Accordingly, these rigid bodies are connected together at joints where their idealized\nsurfaces are in ideal contact without any clearance between them. The respective geometries of these surfaces in contact determine the freedom of motion between the two links, or the joint kinematics."
        },
        {
          "type": "subheading",
          "value": "Revolute"
        },
        {
          "type": "text",
          "value": "The most general form of a revolute joint, often abbreviated as R and sometimes referred to colloquially as a hinge or pin joint, is a lower pair composed of two congruent surfaces of revolution. The surfaces are the same except one of them is an external surface, convex in any plane normal to the axis of revolution, and one is an internal surface, concave in any plane normal to the axis. The position of one body relative to the other may be expressed as the angle between two lines normal to the joint axis, one fixed in each body. Thus, the joint has one degree of freedom (DOF)."
        },
        {
          "type": "subheading",
          "value": "Prismatic"
        },
        {
          "type": "text",
          "value": "The most general form of a prismatic joint, often abbreviated as P and sometimes referred colloquially as a sliding joint, is a lower pair formed from two congruent general cylindrical surfaces. A prismatic joint permits only sliding of one of the members joined relative to the other along the direction of extrusion. The position of one body relative to the other is determined by the distance between two points on a line parallel to the direction of sliding, with one point fixed in each body. Thus, this joint also has one degree of freedom."
        },
        {
          "type": "subheading",
          "value": "Helical"
        },
        {
          "type": "text",
          "value": "The most general form of a helical joint, often abbreviated as H and sometimes referred to colloquially as a screw joint, is a lower pair formed from two helicoidal surfaces formed by extruding any curve along a helical path. The simple example is a bolt and nut wherein the\nbasic generating curve is a pair of straight lines."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "Spherical",
              "url": "https://www.sciencedirect.com/topics/engineering/spherical-joint"
            },
            {
              "name": "Cylindrical",
              "url": "https://en.wikipedia.org/wiki/Cylindrical_joint"
            }
          ]
        },
        {
          "type": "heading",
          "value": "6-DOF Joint"
        },
        {
          "type": "text",
          "value": "The motion of two bodies not jointed together can be modeled as a six-degree-of-freedom joint that introduces no constraints. This is particularly useful for mobile robots, such as aircraft, that make at most intermittent contact with the ground, and thus, a body in free motion relative to the fixed frame is termed a floating base. Such a free motion joint model enables the position and orientation of a floating base in space to be expressed with six joint\nvariables."
        },
        {
          "type": "heading",
          "value": "Geometric Representation"
        },
        {
          "type": "text",
          "value": "The geometry of a robotic mechanism is conveniently defined by attaching coordinate frames to each link. While these frames could be located arbitrarily, it is advantageous both for consistency and computational efficiency to adhere to a convention for locating the frames on the links. A commonly used convention for selecting frames of reference in robotic applications is the Denavit-Hartenberg, or D-H convention. In this convention, each homogeneous transformation $A_{i}$ is represented as a product of four basic transformations"
        },
        {
          "type": "image",
          "src": "/images/handbook/images/link_2.png",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "text",
          "value": "where the four quantities $\\theta_{i} , a_{i} , d_{i} , \\alpha_{i}$ are parameters associated with link i and joint i. The four parameters $a_{i} ,\\alpha_{i} ,d_{i} , and \\: \\theta_{i}$ in are generally given the names link length, link twist, link offset, and joint angle, respectively, three of the above four quantities are constant for a given link, while the fourth parameter, $\\theta i$ for a revolute joint and $d_{i}$ for a prismatic joint, is the joint variable."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "video",
              "url": "https://www.youtube.com/watch?v=FiKEAdednuo"
            },
            {
              "name": "here",
              "url": "https://robotacademy.net.au/lesson/denavit-hartenberg-notation/"
            }
          ]
        },
        {
          "type": "image",
          "src": "/images/handbook/images/dh_parameters.jpg",
          "alt": "Image",
          "caption": ""
        }
      ]
    },
    {
      "id": "kinematics",
      "title": "Forward and Inverse Kinematics",
      "category": "mechanical",
      "excerpt": "Understanding forward and inverse kinematics for robot manipulators and serial-chain mechanisms.",
      "subcategory": "Kinematics",
      "content": [
        {
          "type": "heading",
          "value": "Forward Kinematics"
        },
        {
          "type": "text",
          "value": "The forward kinematics problem for a serial-chain manipulator is to find the position and orientation of the end-effector relative to the base given the positions of all of the joints and the values of all of the geometric link parameters. Often, a frame fixed in the end-effector is referred to as the tool frame, and while fixed in the final link N, it in general has a constant offset in both position and orientation from frame N. Likewise, a station frame is often located in the base to establish the location of the task to be performed. This frame generally has a constant offset in its pose relative to frame 0, which is also fixed in the base. In practice, the forward kinematics problem is solved by calculating the transformation between a coordinate frame fixed in the end-effector and another coordinate frame fixed in the base, i.e., between the tool and station frames. This is straightforward for a serial chain since the transformation describing the position of the end-effector relative to the base is obtained by\nsimply concatenating transformations between frames fixed in adjacent links of the chain."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/forward_kinematics.jpg",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "heading",
          "value": "Inverse Kinematics"
        },
        {
          "type": "text",
          "value": "The inverse kinematics problem for a serial-chain manipulator is to find the values of the joint positions given the position and orientation of the end-effector relative to the base and the values of all of the geometric link parameters. Once again, this is a simplified statement applying only to serial chains. A more general statement is: given the relative positions and orientations of\ntwo members of a mechanism, find the values of all of the joint positions. This amounts to finding all of the joint positions given the homogeneous transformation between the two members of interest. When solving the inverse problem, we often have to choose one solution from a number of valid solutions. There are also degenerate cases with an infinite number of solutions Some solutions of the inverse mapping may not be physically realizable. This is due to manipulators having physical joint limits that prevent the mechanism from achieving certain joint configurations that may be solutions to the inverse kinematics problem (e.g. a joint may not have a full 360 degree motion)"
        },
        {
          "type": "image",
          "src": "/images/handbook/images/Inverse_Kinematics.jpg",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "image",
          "src": "/images/handbook/images/why_ik.png",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "text",
          "value": "To get a more detailed idea of solving inverse and forward kinematics problems for robotic system do checkout this 3 part video series from milfordrobotics"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "Part-1",
              "url": "https://www.youtube.com/watch?v=VjsuBT4Npvk"
            },
            {
              "name": "Part-2",
              "url": "https://www.youtube.com/watch?v=3ZcYSKVDlOc&t=683s"
            },
            {
              "name": "Part-3",
              "url": "https://www.youtube.com/watch?v=llUBbpWVPQE"
            }
          ]
        }
      ]
    },
    {
      "id": "dynamics",
      "title": "Introduction to Dynamics",
      "category": "mechanical",
      "excerpt": "Fundamentals of robot dynamics and motion equations.",
      "subcategory": "Dynamics",
      "content": [
        {
          "type": "heading",
          "value": "Introduction to Dynamics"
        },
        {
          "type": "text",
          "value": "For many applications with fixed-based robots we need to find a multi-body dynamics formulated as:"
        },
        {
          "type": "text",
          "value": "$$ M(q)\\ddot{q} + b(q,\\dot{q}) + g(q) = \\tau \\: + J_{c}(q)^{T}F_{c} $$"
        },
        {
          "type": "text",
          "value": "consisting of the following components:"
        },
        {
          "type": "text",
          "value": "$M(q)$      $\\epsilon$   $\\mathbf{R}$ $^{n_{q}Xn_{q}}$  Generalized Mass matrix(orthogonal)"
        },
        {
          "type": "text",
          "value": "$q, \\dot{q}, \\ddot{q}$     $\\epsilon$   $\\mathbf{R}^{n_{q}}$        Generalized position, velocity and acceleration vectors"
        },
        {
          "type": "text",
          "value": "$b(q, \\dot{q})$    $\\epsilon$   $\\mathbf{R}^{n_{q}}$        Coriolis and centrifugal terms."
        },
        {
          "type": "text",
          "value": "$g(q)$        $\\epsilon$   $\\mathbf{R}^{n_{q}}$        Gravitational terms."
        },
        {
          "type": "text",
          "value": "$\\tau$             $\\epsilon$   $\\mathbf{R}^{n_{q}}$        External generalized forces."
        },
        {
          "type": "text",
          "value": "$F_{c}$          $\\epsilon$   $$\\mathbf{R}^{n_{q}}$         External Cartesian forces (e.g. from contacts)"
        },
        {
          "type": "text",
          "value": "$J_{c}(q)$     $\\epsilon$     $\\mathbf{R}^{n_{q}Xn_{q}}$    Geometric Jacobian corresponding to the external forces."
        },
        {
          "type": "text",
          "value": "Different methods exist to compute the so-called Equations of Motion (EoM) of a given system, i.e., a closed-form mathematical model of the system dynamics. The two most common methods used in robotics are Newton-Euler method which essentially applies the principles of conservation of linear and angular momentum for all links of a robot and Lagrange Method which utilizes scalar energy-based functions over the the space of generalized coordinates which adhere to certain minimization principles, thus resulting in trajectories which automatically satisfy the kinematic constraints of the system."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "lecture",
              "url": "https://www.youtube.com/watch?v=B67ug1yx13E"
            }
          ]
        },
        {
          "type": "heading",
          "value": "Newton-Euler Method"
        },
        {
          "type": "subheading",
          "value": "Newton-Euler for Single Bodies"
        },
        {
          "type": "text",
          "value": "a very well known formulation formed by Newton and Euler using law of angular and linear momentum is :"
        },
        {
          "type": "text",
          "value": "‚Äã                                                                       $\\dot{\\mathsf{p}} _{S}$ = $F_{ext,S}$"
        },
        {
          "type": "text",
          "value": "‚Äã                                                                       $\\dot{\\mathbf{N}}_{S}$ = $T_{ext}$"
        },
        {
          "type": "text",
          "value": "where $F_{ext,S}$ are the resultant external forces that act through the COG and  $T_{ext}$ are the resultant external torques. External forces which do not act through the COG need to be shifted to an equivalent force/moment pair of which the force acts through the COG."
        },
        {
          "type": "subheading",
          "value": "Newton-Euler for Multi-Body Systems"
        },
        {
          "type": "text",
          "value": "When dealing with multi-body systems, a valid approach is to separate all bodies at the joints as depicted in and to consider every body as a single unit. Thereby, the constraint forces F$_{i}$ at the joints must be introduced as external forces acting on each of the bodies when cut free. For all these bodies, we must then apply conservation of linear and angular momentum in all DoFs, subject to external forces (which now include the joint forces F$_{i}$ , too). For a general 3D case and a fixed base, this results in a 6$n_{j}$ -dimensional systems of equations. Additionally, there are 5 $n_{j}$ motion constraint due to the ideal joints. They ensure that the two connected bodies only move along the direction of the joint but don‚Äôt move in all other directions that are blocked by the joint."
        },
        {
          "type": "image",
          "src": "/images/handbook/images/link_1.png",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "heading",
          "value": "Lagrange Method"
        },
        {
          "type": "text",
          "value": "This method is centered around three fundamental concepts:"
        },
        {
          "type": "text",
          "value": "1. The definition of generalized coordinates$ q$ and generalized velocities $\\dot{q}$ , which may or may not encode the information regarding the constraints applicable to the system."
        },
        {
          "type": "text",
          "value": "2. . A scalar function called the Lagrangian function $\\mathcal{L}$. For mechanical systems, it is exactly the difference between the total kinetic energy $\\mathcal{T}$ and the total potential energy $\\mathcal{U}$, of the system at each instant:"
        },
        {
          "type": "text",
          "value": "‚Äã                                                         $\\mathcal{L} = \\mathcal{T} - \\mathcal{U}$"
        },
        {
          "type": "text",
          "value": "3. The so-called Euler-Lagrange equation, also known as the Euler-Lagrange of the second kind, which applies to the Lagrangian function $\\mathcal{L}$ and to the total external generalized forces $\\tau$ :"
        },
        {
          "type": "text",
          "value": "‚Äã                                            $\\frac{d}{dt} (\\frac{\\partial{\\mathcal{L}}}{\\partial{\\dot{q}}} )$  -  $(\\frac{\\partial{L}}{\\partial{\\dot{q}}})$      =   $\\tau$"
        },
        {
          "type": "text",
          "value": "In the most general case, the Lagrangian is a function of the generalized coordinates and velocities q and qÀô , and it may also have an explicit dependence on time t, hence we redefine the aforementioned scalar energy functions as $\\mathcal{T} = \\mathcal{T}(t, q, \\dot{q})$ and $\\mathcal{U} = \\mathcal{U}(t,q)$, thus $\\mathcal{L} = \\mathcal{L}(t,q,\\dot{q})$ ."
        },
        {
          "type": "text",
          "value": "In the end, one of the most notable properties of this formulation is the capacity to eliminate all internal reaction forces of the system from the final EoM, in contrast to the Newton-Euler formulation where there they are explicitly accounted for."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "lecture",
              "url": "https://youtu.be/xc71IuDmZIw"
            }
          ]
        },
        {
          "type": "text",
          "value": "some of the other resources you can checkout to know more about kinematics and dynamics involved in robotics are:"
        },
        {
          "type": "text",
          "value": "1. A Mathematical Introduction to Robotic Manipulation by Richard Murray\n   2. Robot dynamics and control by Mark Spong\n   3. Springer Handbook on Robotics by Oussama Khatib"
        }
      ]
    },
    {
      "id": "simulation-intro",
      "title": "Introduction to Simulation",
      "category": "simulation",
      "excerpt": "Overview of simulation in robotics - why it's essential and how it helps in robot development.",
      "content": [
        {
          "type": "heading",
          "value": "Introduction"
        },
        {
          "type": "text",
          "value": "Simulation is an essential part of Robotics Automation. They provide a versatile\nplatform to quickly test your code for bugs and performance and try out new ideas.\nWhile robots are becoming more accessible all the time, it is still not at the stage where\nyou can test your code directly on them. In fact, running code in simulations will always\nbe more convenient. For a more thorough introduction on simulators and the robots\nyou can find in them, go through **Chapter 6** of Morgan Quigley."
        }
      ]
    },
    {
      "id": "gazebo",
      "title": "Gazebo Simulator",
      "category": "simulation",
      "excerpt": "Gazebo is the most popular physics simulator for robotics development, fully integrated with ROS.",
      "subcategory": "Gazebo",
      "content": [
        {
          "type": "heading",
          "value": "Gazebo"
        },
        {
          "type": "text",
          "value": "Gazebo is the most popular physics simulator for robotics development. It can simulate robots in a\n3D environment and can be fully integrated into ROS integrated with Gazebo using the\n**gazebo_ros** ROS package. You can interface your robots in the simulation using ROS\nand control them using ROS messages and services."
        },
        {
          "type": "subheading",
          "value": "2.1 Installation"
        },
        {
          "type": "text",
          "value": "Gazebo and gazebo_ros package are both automatically installed when you install ROS. To make sure you have all the\nROS packages necessary for running Gazebo simulations are installed"
        },
        {
          "type": "text",
          "value": "`sudo apt-get install ros-melodic-gazebo-*`"
        },
        {
          "type": "text",
          "value": "Gazebo can also be installed independently of ROS by using the command"
        },
        {
          "type": "text",
          "value": "`curl -sSL http://get.gazebosim.org | sh`"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "here",
              "url": "http://gazebosim.org/tutorials?cat=install"
            }
          ]
        },
        {
          "type": "subheading",
          "value": "2.2 Getting Started"
        },
        {
          "type": "text",
          "value": "You can launch the Gazebo GUI simulator window by just running the command `gazebo`\nin the terminal. To understand how to spawn robot models in gazebo it is recommended to first get familiar with _.urdf_, _.sdf_ and _.world_ files. You can refer to the [Robot Description]() section to read about these."
        },
        {
          "type": "text",
          "value": "A file can be opened simply by running the follwing command in the command line:"
        },
        {
          "type": "text",
          "value": "`gazebo <path/to/file>`"
        },
        {
          "type": "subheading",
          "value": "2.3 Client Server Separation"
        },
        {
          "type": "text",
          "value": "Running the `gazebo` command starts two programmes, namely the **gzserver** and the **gzclient**. The _gzserver_ is responsible for doing most of the 'processing' part, i.e., doing all the calculations for the simulation, sensor data generation, basically all the backend processing. The _gzclient_ is responsible for generating the user interface. It provides a nice visualization of simulation, and convenient controls over various simulation properties. _gzserver_ is capable of running independently of _gzclient_ and vice-versa. For eg; in many cases _gzserver_ is run on a cloud computer in case enough processing power is not available locally. Try running the command `gzserver` in one terminal and the command `gzclient` in other terminal. You will notice that the gazebo window pops up only when you run the `gzclient` command. The term **_run headless_** is used to refer to cases when only the _gzserver_ is being used."
        },
        {
          "type": "subheading",
          "value": "2.4 Environment Variables in Gazebo"
        },
        {
          "type": "text",
          "value": "[Environment Variables]() are variables whose values are valid throughout the system and are used by different applications and the OS for several purposes. These environment variables can contain different types of things ranging from parameter values to paths to certain files depending on what they are used for. Gazebo uses various such environment variables too. These variables and their uses are described below:"
        },
        {
          "type": "text",
          "value": "* **GAZEBO_MODEL_PATH :** This environment variable contains colon-separated paths to different directories where gazebo will search for models. Models refers to the sdf file describing the robot. For more information on this refer to the [Robot Description]() section of the handbook.\n  &nbsp;\n* **GAZEBO_RESOURCE_PATH:** This environment variable contains colon-separated set of directories where Gazebo will search for other resources such as world and media files. For eg. if you run the command `gazebo worlds/pioneer2dx.world`. You will see gazebo window pop up with an empty environment. In fact you can execute this command in any directory. You might ask how does gazebo know where the `worlds`  directory is stored?. The answer is that the path to the world directory, that is `/usr/share/gazebo-7/worlds` is stored in the environment variable `GAZEBO_RESOURCE_PATH`.\n&nbsp;\n* **GAZEBO_MASTER__URI:** [URI]() of the [Gazebo master](). This specifies the IP and port where the server(gzserver) will be started and tells the clients(gzclients) where to connect to.\n&nbsp;\n* **GAZEBO_PLUGIN_PATH:** colon-separated set of directories where Gazebo will search for the plugin shared libraries at runtime. Plugins are basically..... You can refer to [this]() section to read more about gazebo plugins.\n&nbsp;\n* **GAZEBO_MODEL_DATABASE_URI:** URI of the online model database where Gazebo will download models from."
        },
        {
          "type": "text",
          "value": "The default values of these environment variables are stored in the `<install_path>/share/gazebo/setup.sh` file. If you want to change the values of this variables for example, add or remove a path from `GITHUB_MODEL_PATH` you will have to source this file first using the command"
        },
        {
          "type": "text",
          "value": "`source <install_path>/share/gazebo/setup.sh`"
        },
        {
          "type": "text",
          "value": "Once this is done you can edit that value of the variable by editing the value by opening the `setup.sh` file or directly thorugh the terminal/command line using the command:"
        },
        {
          "type": "text",
          "value": "`GITHUB_MODEL_PATH=$GITHUB_MODEL_PATH:<path of the directory you want to add>`"
        }
      ]
    },
    {
      "id": "robot-description",
      "title": "Robot Description (URDF/SDF)",
      "category": "simulation",
      "excerpt": "Creating robot descriptions using URDF and SDF formats for Gazebo simulation.",
      "subcategory": "Gazebo",
      "content": [
        {
          "type": "heading",
          "value": "Introduction:"
        },
        {
          "type": "text",
          "value": "Robot models in gazebo serve as the digital counterparts of physical robots, representing their physical characteristics, kinematics, dynamics, and sensors in a virtual setting. These models play a crucial role in various fields, including robotics research, autonomous systems development, and even educational purposes.\nUsing Robot Description Formats, roboticists can rapidly prototype and experiment with various robotic configurations without the need for a physical robot. This capability significantly speeds up the development process, allowing for iterative testing, debugging, and fine-tuning of robot designs and control algorithms before deployment on real hardware."
        },
        {
          "type": "heading",
          "value": "Model:"
        },
        {
          "type": "text",
          "value": "- ### URDF:\n    In Gazebo, URDF files serve as the foundation for creating robot models. A URDF file contains essential information about the robot's mechanical structure, such as links, joints, sensors, and physical properties like mass, inertia, and collision geometry. Additionally, it can define visual elements, enabling users to visualize the robot accurately during simulations.\n    These description files require designs of various components of the robot, hence are usually bundled with a meshes folder having an accessible path. The model files are of the XML format and have the extension `.urdf`; however, if you use macros to clean up the code, it becomes `urdf.xacro`.\n    Refer to [roswiki](http://wiki.ros.org/urdf) for more on urdfs.\n    There are plugins in various 3d modelling softwares that automatically generate urdfs.\n    It can also be done manually. (Using the urdf snippet tool in vscode fast-tracks the process of writing urdfs). Following [tutorials](http://wiki.ros.org/urdf/Tutorials/Building%20a%20Visual%20Robot%20Model%20with%20URDF%20from%20Scratch) would help gain better understanding of its structure, which is imperative for tweaking attributes and on the go customisation. Sometimes, running a software like Gazebo just for visualisation becomes tedious use the URDF previewer that is conveniently part of the ROS extension in Visual Studio Code."
        },
        {
          "type": "text",
          "value": "- ### Methods of spawning:\n    - ##### Writing a simulation description format (SDF) file:\n        - Create a config file.\n        - Including meshes(stl,dae) in .sdf file."
        },
        {
          "type": "text",
          "value": "- ##### Importing using gazebo GUI:\n        In gazebo, navigate to insert/path look for the mesh(.stl;.dae) file and add its path. The model can be dragged directly into the scene and can further be reloaded using the saved world file."
        },
        {
          "type": "text",
          "value": "- ##### Spawn.urdf in the launch file:\n        - Call the spawn.urdf method of the ros_gazebo node from the ros_gazebo package\n        ```xml\n        <node name=\"spawn_model\" pkg=\"gazebo_ros\" type=\"spawn_model\" args=\"-urdf -model urdf_assembly6 -param robot_description -z 1.0\" output=\"screen\" />\n        <!--    model name          urdf          position-->\n        ```\n        - Position the urdf in 3d space (0 0 1.0)"
        },
        {
          "type": "heading",
          "value": "Control:"
        },
        {
          "type": "text",
          "value": "When urdfs are simply spawned into an environment, the joints go limp under the influence of gravity.\nROS (Robot Operating System) Controllers help maintaining a joint state or position and play a fundamental role in controlling robotic systems within the ROS ecosystem. To effectively interact with and control robots, ROS Controllers are employed to handle various aspects of robot behaviour, such as motion control, joint control etc.\nThe primary objective of ROS Controllers is to abstract the complexities of low-level hardware control and provide a unified interface for developers to command and manage robots. This abstraction allows robot designers and developers to focus on higher-level tasks and algorithms without having to deal with specific hardware details."
        },
        {
          "type": "text",
          "value": "- ### Key Components of ROS Controllers:\n    - **Hardware Interface**: The hardware interface is a crucial component of ROS Controllers, responsible for communication between the higher-level control system (software) and the robot's actuators (hardware). This needs to be added in the description file under the transmission tag:\n        ```xml\n           ‚Äò‚Äô<transmission name=\"simple_trans\">\n           \t<type>transmission_interface/SimpleTransmission</type>\n           \t<joint name=\"foo_joint\">\n           \t<hardwareInterface>EffortJointInterface</hardwareInterface>\n            </joint>‚Äô‚Äô\n        ```\n    Refer to [transmission elements](http://wiki.ros.org/urdf/XML/Transmission).\n    - **Controller Plugins**: Controller plugins are modular software components that implement different control algorithms and strategies. These plugins receive high-level commands from the user or other ROS nodes and translate them into low-level control signals that the hardware can understand. Some commonly used controller plugins include joint position controllers, joint velocity controllers, and effort controllers."
        },
        {
          "type": "text",
          "value": "**Controller Manager**: The controller manager is responsible for loading and unloading controller plugins and managing their lifecycle. It provides a centralized interface for activating and deactivating controllers based on user commands or the current robot state. It is loaded into the launch file as a rosparam and is a config file in nature with the extension `.yaml`.\n    ```xml\n  <!-- Load joint controller configurations from YAML file to parameter server -->\n    <rosparam file=\"$(find urdf_assembly6)/config/controllers.yaml\" command=\"load\"/>"
        },
        {
          "type": "text",
          "value": "<!-- load the controllers -->\n    <node name=\"controller_spawner\" pkg=\"controller_manager\" type=\"spawner\" respawn=\"false\"\n        output=\"screen\" ns=\"/manipulator\" args=\"joint1_position_controller joint2_position_controller joint3_position_controller joint_state_controller\"/>\n    ```"
        },
        {
          "type": "text",
          "value": "**Joint State Controller**: The joint state controller is a special type of controller that reads joint states (position, velocity, effort) from the robot's sensors and publishes them to the ROS network. This controller is essential for other controllers that require feedback about the robot's current state."
        },
        {
          "type": "text",
          "value": "**ROS Messages and Services**: ROS Controllers utilize ROS messages and services to receive commands and send feedback to other ROS nodes. This communication mechanism ensures seamless integration with the broader ROS ecosystem."
        },
        {
          "type": "text",
          "value": "- ### Types of ROS Controllers:\n    - **Position Controllers**: Position controllers are used to set the desired joint positions of a robot. They compute the necessary control efforts to reach and maintain these positions."
        },
        {
          "type": "text",
          "value": "- **Velocity Controllers**: Velocity controllers command the desired joint velocities of a robot. They regulate the joint speeds to achieve the desired motion."
        },
        {
          "type": "text",
          "value": "- **Effort Controllers**: Effort controllers apply specific forces or torques to robot joints, allowing for precise control of joint efforts. This type of control is particularly useful for applications requiring high accuracy and force/torque control."
        },
        {
          "type": "text",
          "value": "- **Trajectory Controllers**: Trajectory controllers enable robots to follow predefined trajectories, smoothly interpolating between waypoints."
        },
        {
          "type": "heading",
          "value": "Glossary:"
        },
        {
          "type": "text",
          "value": "- ***Urdfs(Universal Robot Description Format)***-an xml format defining the attributes(inertial,visual) of a single robot. \n- ***Meshes***- models created using interconnected polygons to create a visual and geometric representation of the robot's structure\n- ***SDF(simulation Description Format)***- t is an XML-based file format used to describe the world, objects, and entities in a simulated environment within the Gazebo robotics simulator.\n- ***Xacro***-an xml format used to clean up urdfs by handling repetitive code blocks or macros.\n- ***Transmission tags***- An extension to the URDF robot description model that is used to describe the relationship between an actuator and a joint."
        }
      ]
    },
    {
      "id": "stdr",
      "title": "STDR Simulator",
      "category": "simulation",
      "excerpt": "Simple Two-Dimensional Robot Simulator for quick prototyping.",
      "subcategory": "STDR",
      "content": [
        {
          "type": "subheading",
          "value": "General Introduction"
        },
        {
          "type": "text",
          "value": "STDR is a simple two dimensional robot simulator. It is very useful in cases where there is no need for computationally costly 3-D simulation of robots. It is computationally light and serves the purpose good. Hence it is very useful for learning based robotics or for multi robot simulation."
        },
        {
          "type": "subheading",
          "value": "Installation"
        },
        {
          "type": "text",
          "value": "1. For ROS Kinetic, stdr can be installed using apt-get.\n2. For ROS Melodic, it is advisible to install stdr from [source](https://github.com/stdr-simulator-ros-pkg/stdr_simulator)."
        },
        {
          "type": "subheading",
          "value": "Architecture Overview"
        },
        {
          "type": "image",
          "src": "/images/handbook/images/architecture.jpg",
          "alt": "Image",
          "caption": ""
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "ROS Wiki",
              "url": "http://wiki.ros.org/stdr_simulator"
            }
          ]
        },
        {
          "type": "subheading",
          "value": "Basic Usage"
        },
        {
          "type": "text",
          "value": "- The ```stdr_launchers``` package contains launch files basic usage. However, custom launch files can be created to serve personal purposes easily. Some of the launch files are\n\t1. ```server_no_map.launch``` launches the stdr server without any map, robot or the gui.\n\t2. ```server_with_map_and_gui.launch``` launches the serve with preloaded map and gui.\n\t3. ```server_with_map_and_gui_plus_robot.launch``` launches the stdr_server, with preloaded map and robot along with the gui\n- You can also launch Rviz with a preset config file using ```rviz.launch``` file in the stdr_launchers package."
        },
        {
          "type": "subheading",
          "value": "Robot Namespaces"
        },
        {
          "type": "text",
          "value": "1. The topics corresponding to each robot have a unique namespace attached to it. For example the first robot launched has a namespace ```/robot0```. Published topics pertaining to that robot are published as ```/robot0/topic_name```.\n2. Note that whenever a new robot is spawned the robot number is incremented by 1. This happens even though you delete a robot.\n3. such namespacing avoids conflicts of topic names when doing multi robot simulation."
        },
        {
          "type": "subheading",
          "value": "References"
        },
        {
          "type": "text",
          "value": "1. For more information refer the ```stdr_simulator``` page  in [ROS Wiki](http://wiki.ros.org/stdr_simulator).\n2. The github [repository](https://github.com/stdr-simulator-ros-pkg/stdr_simulator) for stdr_simulator."
        }
      ]
    },
    {
      "id": "about",
      "title": "About the Handbook",
      "category": "about",
      "excerpt": "About the ERC Handbook and how to contribute.",
      "content": [
        {
          "type": "heading",
          "value": "About Us"
        },
        {
          "type": "text",
          "value": "The Electronics and Robotics Club (ERC) of BITS Goa is a diverse group of students with interests ranging from electronics to machine learning to mechanical design. Over the years, we have evolved into a platform to learn and experiment with various aspects of science and engineering and to apply them in robotics. We are open to anyone with a general interest in engineering and who wants to explore robotics, so feel free to get in touch with us."
        },
        {
          "type": "text",
          "value": "This handbook is part of an effort from our side to provide an organised set of learning resources to make it easy for anyone to get started with the field of robotics. We have compiled a bunch of staple and commonly used resources in an orderly fashion giving a breadth-first overview of basic concepts essential in all the three significant verticals of robotics: **Design, Electronics and Control and Automation**."
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "issue",
              "url": "https://github.com/ERC-BPGC/handbook/issues"
            },
            {
              "name": "PRs",
              "url": "https://github.com/ERC-BPGC/handbook/pulls"
            }
          ]
        },
        {
          "type": "text",
          "value": "We hope this handbook helps you in some or the other way!"
        },
        {
          "type": "resources",
          "items": [
            {
              "name": "website",
              "url": "https://erc-bpgc.github.io/"
            },
            {
              "name": "blog",
              "url": "https://erc-bpgc.github.io/blog/"
            }
          ]
        }
      ]
    },
    {
      "id": "misc",
      "title": "Miscellaneous Resources",
      "category": "misc",
      "excerpt": "Additional resources and useful links for robotics enthusiasts.",
      "content": [
        {
          "type": "heading",
          "value": "Miscellaneous"
        },
        {
          "type": "heading",
          "value": "Online Courses"
        },
        {
          "type": "text",
          "value": "- [Underactuated robotics](https://www.youtube.com/channel/UChfUOAhz7ynELF-s_1LPpWg/videos)\n- [Programming for Robotics](https://rsl.ethz.ch/education-students/lectures/ros.html)\n- [Introduction to Aerial Robotics](http://www.kostasalexis.com/introduction-to-aerial-robotics.html)\n- [SLAM Course](https://www.youtube.com/playlist?list=PLgnQpQtFTOGQrZ4O5QzbIHgl3b1JHimN_)\n- [Robotics Specialization - Coursera](https://www.coursera.org/specializations/robotics)\n- [Modern Robotics Specialization - Coursera](https://www.coursera.org/specializations/modernrobotics)\n- [Compiled list of other courses/resources](https://github.com/mithi/robotics-coursework)"
        },
        {
          "type": "heading",
          "value": "Wesbites with resources"
        },
        {
          "type": "text",
          "value": "- [The Robotics Back-End](https://roboticsbackend.com/)\n- [RoboticsKnowledgeBase](https://roboticsknowledgebase.com/)"
        },
        {
          "type": "heading",
          "value": "Talk Series / Seminars / Podcasts"
        },
        {
          "type": "text",
          "value": "- [Artificial Intelligence Podcast by Lex Fridman](https://www.youtube.com/playlist?list=PLrAXtmErZgOdP_8GztsuKi9nrraNbKKp4)\n- [Robotics Today](https://roboticstoday.github.io/index.html)\n- [MIT RoboSeminars](https://www.youtube.com/channel/UCK2tKzmSFFnpFhUXtRKjvnQ)\n- [Stanford - Robotics and Autonomous Systems Seminar](https://www.youtube.com/playlist?list=PLoROMvodv4rMeercb-kvGLUrOq4HR6BZD)\n- [CMU RI Robotics Seminars](https://www.youtube.com/playlist?list=PLCFD85BC79FE703DF)"
        },
        {
          "type": "heading",
          "value": "List of Mailing lists and Google Groups"
        },
        {
          "type": "text",
          "value": "- [Robotics Worldwide](http://robotics-worldwide.1046236.n5.nabble.com/)"
        },
        {
          "type": "text",
          "value": "- [European Robotics](https://lists.iais.fraunhofer.de/sympa/info/euron-dist)"
        },
        {
          "type": "text",
          "value": "- [AI Robotics](https://groups.google.com/forum/#!forum/ai-robotics)"
        },
        {
          "type": "text",
          "value": "- [Systems Neuroscience](https://groups.google.com/group/systems-neuroscience/subscribe)"
        },
        {
          "type": "text",
          "value": "- [ML-news](https://groups.google.com/forum/?hl=en#!forum/ML-news)"
        },
        {
          "type": "text",
          "value": "- [Connectionists](https://mailman.srv.cs.cmu.edu/mailman/listinfo/connectionists)"
        },
        {
          "type": "text",
          "value": "- [UAI](https://secure.engr.oregonstate.edu/mailman/listinfo/uai)"
        },
        {
          "type": "text",
          "value": "- [Reinforcement Learning](https://groups.google.com/forum/?fromgroups#!forum/rl-list)"
        },
        {
          "type": "text",
          "value": "- [Deep Learning](https://plus.google.com/communities/112866381580457264725)"
        },
        {
          "type": "text",
          "value": "- [Neuromorphic Engineering](https://plus.google.com/communities/106429639703340584547)"
        },
        {
          "type": "text",
          "value": "- [Computer Vision](http://visionscience.com/mailman/listinfo/visionlist)"
        },
        {
          "type": "text",
          "value": "- [Artificial Life](http://lists.idyll.org/listinfo/alife-announce)"
        },
        {
          "type": "text",
          "value": "- [Genetic Programming](http://tech.groups.yahoo.com/group/genetic_programming/)"
        }
      ]
    }
  ]
}